{"0": {
    "doc": "Just the Class",
    "title": "Just the Class",
    "content": "Just the Class is a GitHub Pages template developed for the purpose of quickly deploying course websites. In addition to serving plain web pages and files, it provides a boilerplate for: . | announcements, | a course calendar, | a staff page, | and a weekly schedule. | . Just the Class is a template that extends the popular Just the Docs theme, which provides a robust and thoroughly-tested foundation for your website. Just the Docs include features such as: . | automatic navigation structure, | instant, full-text search and page indexing, | and a set of UI components and authoring utilities. | . ",
    "url": "/cs142-f22/index.html",
    "relUrl": "/index.html"
  },"1": {
    "doc": "Just the Class",
    "title": "Getting Started",
    "content": "Getting started with Just the Class is simple. | Create a new repository based on Just the Class. | Update _config.yml and README.md with your course information. Be sure to update the url and baseurl. | Configure a publishing source for GitHub Pages. Your course website is now live! | Edit and create .md Markdown files to add more content pages. | . Just the Class has been used by instructors at Stanford University (CS 161), UC Berkeley (Data 100), UC Santa Barbara (CSW8), Northeastern University (CS4530/5500), and Carnegie Mellon University (17-450/17-950). Share your course website and find more examples in the show and tell discussion! . Local development environment . Just the Class requires no special Jekyll plugins and can run on GitHub Pages’ standard Jekyll compiler. To setup a local development environment, clone your template repository and follow the GitHub Docs on Testing your GitHub Pages site locally with Jekyll. ",
    "url": "/cs142-f22/index.html#getting-started",
    "relUrl": "/index.html#getting-started"
  },"2": {
    "doc": "Coding Style",
    "title": "COMP 142: Coding Style",
    "content": "Just like when writing in English, using good style when writing in a programming language is important because it helps you and other people read your code. Easily-readable code is important for you so you can maintain it (update it later), and for other people so they can figure out what it does as easily as possible, and possibly change it. In this class, when writing in Java, you should follow these coding style guidelines: . ",
    "url": "/cs142-f22/coding-style/#comp-142-coding-style",
    "relUrl": "/coding-style/#comp-142-coding-style"
  },"3": {
    "doc": "Coding Style",
    "title": "General style",
    "content": ". | Use good modular design. Think carefully about the functions and data structures (variables) that you are creating before you start writing code. | The main() function should not contain low-level details. In other words, the main() function should be a high-level overview of your solution, with the low-level details hidden in functions. This is the idea of abstraction. | As a general guide, no function should be longer than a page of code. There are exceptions, of course, but these should truly be for exceptional cases. | Use good error detection and handling. Always check return values from functions and handle errors appropriately. | Try to keep the length of each line manageable. A single Java statement can be split over multiple lines anywhere where a space would be allowed. Unlike Python, no extra syntax (like a backslash) is necessary. | . ",
    "url": "/cs142-f22/coding-style/#general-style",
    "relUrl": "/coding-style/#general-style"
  },"4": {
    "doc": "Coding Style",
    "title": "Comments",
    "content": ". | Use comments liberally throughout your code, especially to explain any complex, tricky, or easily misunderstood sections. | Every program should begin with a comment block giving the following information: . | Your name, the date, and the class. | The honor pledge saying you have neither given nor received any help you weren’t supposed to. | A description of the program (a few sentences describing what the program does). | . | Here is an example: /* Name: Phil Kirlin Date: 9/9/2021 Class: CS142 Pledge: I have neither given nor received unauthorized aid on this program. Description: Skynet is a artificial intelligence system which guides the global digital defense network. It will not start a nuclear war. The user types commands to Skynet such as \"launch probe\" or \"send Terminator back in time.\" The program reports back details such as the state of the Skynet system after each command, including statistics about number of Terminators created, dollars spent, and nuclear wars started (should always be zero). */ . For every function you write (except main), you must include a comment immediately before the function definition line that contains: . | A description of what the function does. | Details about the meanings of each of the parameters to the function. | A description of the meaning of the return value of the function, if there is one. Here’s an example: /* This function computes the circumference of a circle. Parameters: r, the radius of the circle. Returns: the circumference of the circle. */ public static double circumferenceOfCircle(double r) { return 2 * 3.14 * r; } . | . ",
    "url": "/cs142-f22/coding-style/#comments",
    "relUrl": "/coding-style/#comments"
  },"5": {
    "doc": "Coding Style",
    "title": "Indentation and curly braces",
    "content": ". | Java does not force you to indent your code, but it drastically improves readability. | By default, the body of any if/else statement, loop, or function, should be indented the same number of spaces or tabs. This ensures that the lines of code that form the body can be easily distinguished from the rest of your program. | Use a consistent curly brace style. You may choose to have an opening curly brace on the same line of code as the if/else test or function definition, or on a line by itself immediately following. The closing curly brace should be on a line by itself (with a few exceptions). | You should pick an indentation style, and a style of using curly braces, and stick with it consistently within a single program. | Two common indentation styles are: . while (x == y) { something(); somethingElse(); } . and: . while (x == y) { something(); somethingElse(); } . I recommend using one of these, though there are some others you’ll sometimes see. | Exceptions: You may break your curly brace style in the following situations: . | An if/else body has exactly one line of code. You may drop the curly braces here. You should still indent the single line. | Some people like this if/else style that merges some curly braces and the else statement: if (test) { something(); somethingElse(); } else { aThirdThing(); aFourthThing(); } . You may use it if you like. | . | . ",
    "url": "/cs142-f22/coding-style/#indentation-and-curly-braces",
    "relUrl": "/coding-style/#indentation-and-curly-braces"
  },"6": {
    "doc": "Coding Style",
    "title": "Variable and function names",
    "content": ". | Variable and function names should be chosen to reflect the meaning and/or use of the variable or function. Single-character or generic names for variables (e.g., a, b, x, y, ch, num) are only appropriate when a variable is used in a very limited context, and is never used outside of that context (for instance, loop counter variables or iterator variables). | Variable and function names typically begin with a lowercase letter. | The “Java style” for variable names is to use “camel case,” where the first letter of each word (other than the first) is putInUpperCase. | . ",
    "url": "/cs142-f22/coding-style/#variable-and-function-names",
    "relUrl": "/coding-style/#variable-and-function-names"
  },"7": {
    "doc": "Coding Style",
    "title": "The honor pledge",
    "content": "Because we are writing complex programs, it is not uncommon to get stuck. However, as the syllabus states, all homework assignments you complete outside of class must be entirely your own work, with the exception of help from the instructor, tutors, or other people while respecting the “Rules for Completing Assignments Independently” (see the syllabus). I’m asking everyone to please include the honor pledge in the comments at the top of your programs indicating you have conformed to the request to work individually. (See the example above for the text to include.) . ",
    "url": "/cs142-f22/coding-style/#the-honor-pledge",
    "relUrl": "/coding-style/#the-honor-pledge"
  },"8": {
    "doc": "Coding Style",
    "title": "Coding Style",
    "content": " ",
    "url": "/cs142-f22/coding-style/",
    "relUrl": "/coding-style/"
  },"9": {
    "doc": "Lab 3",
    "title": "CS 142 Lab 3",
    "content": " ",
    "url": "/cs142-f22/labs/lab3/#cs-142-lab-3",
    "relUrl": "/labs/lab3/#cs-142-lab-3"
  },"10": {
    "doc": "Lab 3",
    "title": "Tic Tac Toe",
    "content": "In this lab, you will play and modify a game already written for you in Java. Through playing the game and investigating the code, you will practice with using functions, Java objects, calling instance methods, and multidimensional arrays. Getting started . | Start IntelliJ. Load up the same project you were using for lab 2. Otherwise, you may start a new project by following the lab 2 directions and using the same URL. | In the left-hand panel, expand the src folder to see today’s lab (in the lab3 folder). Double-click on TicTacToe (not the md file yet.) If you get a yellow bar at the top that says “Project JDK is not defined,” then click on “Setup SDK” and choose the JDK you downloaded earlier. | In the left-hand panel, double-click on TicTacToe.md. Follow the instructions in this file. This is where you will answer the questions for the lab. | . Note: You do not need to open the SimpleCanvas file. Submitting the lab . When you and your partner are done, please turn in the TicTacToe.java file and the TicTacToe.md file to canvas. ",
    "url": "/cs142-f22/labs/lab3/#tic-tac-toe",
    "relUrl": "/labs/lab3/#tic-tac-toe"
  },"11": {
    "doc": "Lab 3",
    "title": "Lab 3",
    "content": " ",
    "url": "/cs142-f22/labs/lab3/",
    "relUrl": "/labs/lab3/"
  },"12": {
    "doc": "Lab 4",
    "title": "CS 142 Lab 4",
    "content": " ",
    "url": "/cs142-f22/labs/lab4/#cs-142-lab-4",
    "relUrl": "/labs/lab4/#cs-142-lab-4"
  },"13": {
    "doc": "Lab 4",
    "title": "Self-Driving Racecars",
    "content": "In this lab, you will play and modify a program already written for you in Java. Through using the program and modifying it, you will practice with designing and usingn your own classes. Getting started . Follow the instructions given to you. Submitting the lab . When you and your partner are done, please turn in the Java files and the questions.md file. ",
    "url": "/cs142-f22/labs/lab4/#self-driving-racecars",
    "relUrl": "/labs/lab4/#self-driving-racecars"
  },"14": {
    "doc": "Lab 4",
    "title": "Lab 4",
    "content": " ",
    "url": "/cs142-f22/labs/lab4/",
    "relUrl": "/labs/lab4/"
  },"15": {
    "doc": "Labs",
    "title": "Labs",
    "content": " ",
    "url": "/cs142-f22/labs/",
    "relUrl": "/labs/"
  },"16": {
    "doc": "Project 4",
    "title": "CS 142 Project 4: Triwizard Tournament Maze",
    "content": ". | Demo | Starter code | Concepts in this program . | Maze text files | Backtracking | Recursive formulations | Breadcrumbs | Drawing the maze | . | Implementing the project . | Step 1: Decide on instance variables for your maze | Step 2: Reading a maze from a text file | Step 3: Drawing the maze with and without the patronus | Step 4: Get the boolean solver working | Step 5: Get the directional solver working | . | Sample output | Final reminders | What to turn in | Reminders | Challenges | . In Harry Potter and the Goblet of Fire, Harry and three other students participate in the Triwizard Tournament, which culminates in having to navigate a large maze, searching for the Triwizard Cup hidden inside. Harry knows that there are many dangers hidden in the maze, so he would like to find the quickest route from his starting location to wherever the cup is hidden, to minimize the amount of time he actually spends inside the maze. To help him, he decides to send his patronus* into the maze ahead of him, while he waits at the start of the maze. The patronus will explore the maze and through a process called backtracking, discover the shortest path from Harry’s location to the cup. *In the Harry Potter series, a patronus is a spirit or apparition that a witch or wizard can cast. You don’t have to know anything specific about them, or other facts about Harry Potter, other than the patronus is the character that is moving around the maze and determining the shortest path in this project. In this project, you will write a program to open a text file containing a description of a maze, use a recursive algorithm to discover the fastest way through the maze to the Triwizard Cup, and print out the solution at the end, along with some other statistics. ",
    "url": "/cs142-f22/projects/proj4/#cs-142-project-4-triwizard-tournament-maze",
    "relUrl": "/projects/proj4/#cs-142-project-4-triwizard-tournament-maze"
  },"17": {
    "doc": "Project 4",
    "title": "Demo",
    "content": "&gt; Your browser does not support the video tag. ",
    "url": "/cs142-f22/projects/proj4/#demo",
    "relUrl": "/projects/proj4/#demo"
  },"18": {
    "doc": "Project 4",
    "title": "Starter code",
    "content": "Make sure you create the project in a place on your computer where you can find it! I suggest making a new subfolder in your CS 142 projects folder. You can download the starter code for this assignment by creating a new IntelliJ project from version control (VCS) and using the following URL: . https://github.com/pkirlin/cs142-f22-proj4 . ",
    "url": "/cs142-f22/projects/proj4/#starter-code",
    "relUrl": "/projects/proj4/#starter-code"
  },"19": {
    "doc": "Project 4",
    "title": "Concepts in this program",
    "content": "Maze text files . Each text file describing a maze is organized into lines. The first line of each file always contains two integers: the number of rows in the maze and the number of columns. Each of the following lines will contain a single string, representing a single row of the maze. Here is an example file (maze0.txt): . 5 4 #### # ## # C# #H## #### . This file describes a 5-row, 4-column maze, though a maze may have any number of rows and any number of columns. The hash marks (#) specify hedges in the maze that the patronus cannot go through; it is guaranteed that there will always be a complete hedge border on the outer boundary of the maze file (so the patronus cannot leave the boundaries of the maze). Harry’s starting position in the maze is specified by the letter H, and the Triwizard Cup that Harry (and the patronus) is seeking is marked by the letter C. Blank spaces specify open sections of the maze where the patronus is allowed to move as it searches for the cup. Backtracking . We will explore two different recursive formulations of finding the shortest path through the maze, which we will refer to as solving the maze. Both formulations, however, use a concept called backtracking, which is a common computational technique used in situations where we must construct a solution to a problem incrementally piece-by-piece. Often during this process we will have a number of candidate pieces that might work in the solution, but we don’t know ahead of time which ones will work and which ones won’t. So we try all of them one at a time. If we encounter a situation where it is clear our current partial solution is not going to pan out, then we will backtrack to try a new solution. This technique is often used when people try to solve a jigsaw puzzle. Imagine a large section of the puzzle that is already completed, and we try to fit new individual puzzle pieces into the whole puzzle. If a piece doesn’t fit, we remove it (backtrack) and try another piece in its place. Eventually the entire puzzle is completed. Backtracking can be used to solve many interesting problems, including puzzles like mazes, but also optimization problems that occur in the real world such as matching medical students to residency training programs, determining airline routes, scheduling work shifts, or deciding where to place a group of new stores in a city. Backtracking is often used in a recursive fashion, because recursion automatically backtracks when it reaches the base case. If you are interested, you can read more about backtracking on Wikipedia. Recursive formulations . We will develop two recursive formulations to solve a maze. They both use the same idea, but return slightly different kinds of answers. In our first formulation, we will simply determine whether or not the maze can be solved. In other words, this is a boolean (yes/no, true/false) question. Is there a path from Harry to the cup at all? . In the second formulation, we will determine the actual route that Harry can take from his starting location to the cup (sometimes called a path). The route will be a sequence of north/south/east/west directions, indicating the precise sequence of steps Harry must take in the maze. The recursive functions we will design around these formulations will be based on the current location of the patronus in the maze (a specific row and column). The base case in both formulations is when the patronus is located at the same place as the cup. At this point, the cup is found, so we know there is a way for Harry to get from his starting location to the cup. The recursive case in both formulations is similar. The idea is that if the patronus is not located exactly where the cup is, then there are four possible ways to continue solving the maze, each one involving a recursive call: . | Is there a solution to the maze from one step north from the patronus’s current location? | Is there a solution to the maze from one step south from the patronus’s current location? | Is there a solution to the maze from one step east from the patronus’s current location? | Is there a solution to the maze from one step west from the patronus’s current location? | . The idea is to make (up to) four recursive calls, from each of the four squares of the maze surrounding the patronus’s current location. Not all four of these calls will be “legal,” in that one or more of the four squares might be blocked by hedges, . Formulation 1: Can the maze be solved? In our first formulation, the patronus must simply determine if the maze can be solved. Here, we don’t care about the path taken from the starting position to the cup’s position. To solve this problem, the patronus says, “Am I currently located where the cup is located?” (the base case). If so, then we are done (success!). If the patronus is not located where the cup is, it will try to take one step north, and try to solve the maze recursively from that new location. If that didn’t work, it will try to take one step south, and try to solve the maze recursively from that location. It will do the same thing for east and west. If one of those four recursive cases succeeds in solving the maze, then we is done (also success!). If none of the recursive cases solves the maze, then we is done (but with failure). [ See an example of how the recursive formulation works on a sample maze. ] . Formulation 2: What are the precise steps to solve the maze? The first formulation works, but the problem is is only returns success or failure, not the path taken through the maze. To remedy this, let’s change our recursive formulation to return strings rather than success or failure. Each string will represent the path through the maze from the starting location to the cup: we’ll use “N”, “S”, “E”, and “W” for the four cardinal directions, and “C” for the cup. If a path can’t be found, we’ll use “X” for failure. [ See an example of how the recursive formulation works on a sample maze. ] . Your program will implement both recursive formulations. Breadcrumbs . We will use “breadcrumbs” for marking what squares in the maze the patronus has already visited. The patronus, when moving onto a square of the maze, will drop a (virtual) breadcrumb, marking that square as visited. When the patronus is evaluating its surrounding directions to recurse on, it must make sure never to recurse on a square of the maze with a breadcrumb in it. This will prevent it from walking in circles. A breadcrumb is placed in a square at the beginning of each recursive function. It is only removed if we reach a dead end, and therefore, when the algorithm finds the cup, we can be guaranteed that there will be a single trail of breadcrumbs from start to finish. In your code, you will represent breadcrumbs by a period character '.'. When the code asks you to drop a breadcrumb, you will literally alter the current character in the maze from a blank space to a lowercase period. If the patronus determines that the recursion fails in all four possible directions, the breadcrumb will be picked back up (turned back into a blank character). Drawing the maze . The maze will be drawn in a similar fashion to previous projects that used grids (gumdrop gatherer, tic-tac-toe, car racing), in that each square of the maze will be drawn as a square on the board with various features. The exact drawing specifications are up to you, but here are the requirements: . | Pick different colors for the hedges, the open squares of the maze, the location of the cup, and Harry/the patronus’s starting location. I used (gray, white, orange, and red for these, respectively). | The patronus and breadcrumbs can be drawn either as squares or as dots on squares. I think dots look nicer, but pick whichever you like more. | . ",
    "url": "/cs142-f22/projects/proj4/#concepts-in-this-program",
    "relUrl": "/projects/proj4/#concepts-in-this-program"
  },"20": {
    "doc": "Project 4",
    "title": "Implementing the project",
    "content": "For this project, I will provide guidance in terms of a suggested order of writing different parts of the project, but you will have to make more design decisions about what functions and variables to use. There may be times when you want to adjust the public/private-ness of methods, or add more parameters. This is ok. Begin by getting acquainted with the code. Unlike the previous project, this one only uses two main classes (plus SimpleCanvas). | Maze.java: The Maze class is the heart of the project. It represents the current state of the maze, and includes methods to load a maze from a text file, print the maze (in text form), draw the maze on a canvas, and solve the maze in two different ways. | RunTournament.java: This class is just a “driver” class for the Maze; it is equivalent to other classes we’ve looked at with “Demo” in their name. It solely exists to get the project started from a main() method, and also contains testing code that you will fill in. | . Also take a look at the text files you are provided. Notice how each file begins with a line with the dimensions of the maze (rows &amp; columns), followed by the contents of the maze itself. Remember: # is a wall (hedge) of the maze, a space is an open square in the maze, H is where Harry begins, and C is the location of the cup (the end of the maze). Each maze is solvable except maze3-broken.txt, which is purposefully unsolvable. Step 1: Decide on instance variables for your maze . Before you can start writing code, you must decide how to store what the maze looks like. This can be done in various ways, such as with a 2-d array of chars, or an array or ArrayList of Strings, or even an ArrayList of ArrayList of Characters (2-d ArrayList). Add appropriate instance variables to the Maze class to store the contents of the maze itself (what you read from the textfile). You will probably want to add variables to store the dimensions of the maze as well. Note: I think the easiest option is char[][] for the data type of the maze, because then you can use the gumdrop program as a model for many of the algorithms you will write here. Using char[][] makes the file-reading code a little trickier, but I think makes the remainder of the program more straightforward. Using an ArrayList&lt;String&gt; makes it easier to write the file-reading code, but then accessing characters within the maze requires two method calls (one to get() and one to charAt(). Furthermore, when you must modify the maze to drop breadcrumbs, this requires replacing the entire row of the maze, since in Java you can’t modify individual characters within strings.) . Step 2: Reading a maze from a text file . The first piece you will want to get working is reading the maze from a text file. | There is a function called loadMaze() in Maze.java that takes a string — the name of a text file — as a parameter. What I suggest doing is next is either modifying the constructor for Maze so it also takes a filename String parameter, and then inside the constructor, you can call loadMaze(), passing in that string as the name of the text file. Or, you can forget the constructor, and turn loadMaze() into a public function, and call it yourself. There are comments in the function to help you along, but the idea is you should read the text file and store its contents into whatever variables you created in Step 1. | Stop and test. Write the testFileReading() function in RunTournament. I suggest having the function create a new Maze object, then loading one of the sample text files (you can either keep changing the function to try multiple files, or you can make a Scanner to have the user type it in. This is just testing code so it doesn’t matter too much.) Depending on how choices you made above, you may need to call loadMaze() yourself, or the constructor will call it for you. Use print statements in your loadMaze() function to print out the file as it’s being read, and make sure everything is working correctly. | . | Write the printMaze() function in Maze next. This function is mostly used for debugging, but like in the gumdrop program, it’s important to be able to see the contents of the maze textually. | Stop and test. Write some additional code in testFileReading() to print out the maze after it was read from the file using your printMaze() function. | . | . Step 3: Drawing the maze with and without the patronus . Next we will focus on the two functions in Maze called drawMaze() and drawMazeWithPatronus(). They do the same basic task — draw the maze — but because the patronus is not represented in the maze itself (it is not a character like H or C), it needs the separate parameters that drawMazeWithPatronus() has. | The Maze constructor opens a SimpleCanvas, but its width and height are initially zero. Modify these dimensions to make the width and height of the canvas be based on the size of the maze you read in. Depending on how you wrote loadMaze(), you might need to move the call to the SimpleCanvas constructor and the call to show() to the end of loadMaze() if the Maze constructor doesn’t automatically call loadMaze(). | Hint: Like in tic-tac-toe and the gumdrop program, you will need to choose how big the squares are drawn on the canvas. I suggest 30-by-30. | . | Fill in the code for drawMaze(). I suggest using your gumdrop program and/or tic-tac-toe as a guide, because the concepts are identical. Follow the guidelines above for drawing hedges, open squares, the cup, and Harry’s starting position. | Stop and test. Write the testDrawing() function in RunTournament. This test function should read in a maze file and then call drawMaze() so it will be seen on the canvas. | Examples: maze0.txt maze1.txt maze2.txt | . | Fill in the code for drawMazeWithPatronus(). This function will be very short, because all you need to do is call your drawMaze() function and then draw a dot for where the patronus is. | Stop and test. Write the testDrawingPatronus() function in RunTournament. This test function should read in a maze file and then call drawMazeWithPatronus() so it will be seen on the canvas. Note that the maze doesn’t specify where the patronus is, so you should make up some test coordinates for where it is. | Example: maze1.txt with patronus at row 1, col 2: | . | Note: If you cannot get the drawing code to work, you can still proceed to the following steps, using your printMaze() function instead of drawMaze(). | . Step 4: Get the boolean solver working . In this step, we will write the first recursive formulation of the problem, which determines if the maze can be solved. This is done by implementing the functions canSolve() and canSolve(int patronusRow, int patronusCol). The first of these is the public function that you will call from RunTournament, but the work actually happens in the second, private function which takes the position of the patronus as arguments. | Write the no-argument canSolve() first. Follow the guidelines in the code. Don’t worry about the second canSolve() function yet. | Stop and test. This is to verify that you’ve found Harry’s location (the initial location for the patronus correctly). Fill in testBooleanSolver() in RunTournament. Make a simple test function that loads a maze and calls canSolve() (which won’t do much yet). Have canSolve() print out Harry’s location. Verify it is correct. | . | Now have canSolve() call canSolve(int patronusRow, int patronusCol), passing in Harry’s location, because that’s where the patronus begins. Then write the 2-argument version of canSolve. This is the trickiest part of the assignment, because this is where the recursion happens. Use lots of print statements and/or the debugger to get this to work. You must print the location of the patronus at the beginning and ending of this function. | You may need to go back to your drawing code to get the breadcrumbs to show up. | Sample run through for the boolean solver: . Your browser does not support the video tag. | Once the boolean solver is working, we can start transitioning our program towards the final version. At this point, you should write code in main() to make the program work more like the examples near the end of this webpage. Specifically, your program should: . | Ask the user for which maze file they want to read. | Ask the user for the amount of time they want to pause between movements on the canvas (you may want to add an additional instance variable in Maze, and either another method to Maze, or change the constructor so get this value into the Maze class somehow). | Ask the user if they want to run the boolean solver or the directional solver (you can skip this for now if you want, since the directional solver isn’t written yet). | Run the solver. You should print out the maze at the beginning and end in text. You should also print out whenever the patronus enters a new square or backtracks (you should already have done this in canSolve()). | One new part to add is you should keep track of the total number of calls to canSolve that are made, and print this out at the end. You will need to add a new instance variable in Maze to keep track of this. | . | . | Stop and test. At this point you should test your maze solver against the examples in the section below. Verify that the printing of the maze, calls to the patronus entering and backtracking, and the final number of calls matches mine. | . Step 5: Get the directional solver working . In this step, we will write the second recursive formulation of the problem, which determines how the maze can be solved. This is done by implementing the functions directionalSolve() and directionalSolve(int patronusRow, int patronusCol). These two functions work similarly so the two canSolve functions. The only major difference is that instead of returning a boolean, they return a string, consisting of directions from the starting location to the cup. Each direction is a character: N (north), S (south), E (east), or W (west). | Write these two functions, following the guidance in the code. The only hard part is changing the code to work with string answers instead of boolean answers. | Sample run through for the directional solver: . Your browser does not support the video tag. | Stop and test. At this point you should test your maze solver against the examples in the section below. Verify that the printing of the maze, calls to the patronus entering and backtracking, and the final number of calls matches mine. | . ",
    "url": "/cs142-f22/projects/proj4/#implementing-the-project",
    "relUrl": "/projects/proj4/#implementing-the-project"
  },"21": {
    "doc": "Project 4",
    "title": "Sample output",
    "content": ". | maze0: [ Boolean solver ] [ Directional solver ] | maze1: [ Boolean solver ] [ Directional solver ] | maze2: [ Boolean solver ] [ Directional solver ] | maze3: [ Boolean solver ] [ Directional solver ] | maze3-broken: [ Boolean solver ] [ Directional solver ] | maze4: [ Boolean solver ] [ Directional solver ] | maze5: [ Boolean solver ] [ Directional solver ] | . ",
    "url": "/cs142-f22/projects/proj4/#sample-output",
    "relUrl": "/projects/proj4/#sample-output"
  },"22": {
    "doc": "Project 4",
    "title": "Final reminders",
    "content": "Your code should: . | Prompt the user for a filename, pause time, and which solver to use. | Display the maze textually, run the desired solver, and display the maze again afterwards. The second text maze display should show the final breadcrumbs path. | As the solver is running, the graphical display should show the breadcrumbs and the patronus as the maze is being explored. | When done, your program should display the total number of calls to the solver, along with the final path directions and length of the path, if using the directional solver. Meanwhile, in text, it should show the progress of the patronus and the backtracking. | . ",
    "url": "/cs142-f22/projects/proj4/#final-reminders",
    "relUrl": "/projects/proj4/#final-reminders"
  },"23": {
    "doc": "Project 4",
    "title": "What to turn in",
    "content": "Through Canvas, turn in all your .java files. Additionally, upload a text file answering the following questions: . | What bugs and conceptual difficulties did you encounter? How did you overcome them? What did you learn? | Describe whatever help (if any) that you received. Don’t include readings, lectures, and exercises, but do include any help from other sources, such as websites or people (including classmates and friends) and attribute them by name. | Describe any serious problems you encountered while writing the program. | Did you do any of the challenges (see below)? If so, explain what you did. | List any other feedback you have. Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it. | . ",
    "url": "/cs142-f22/projects/proj4/#what-to-turn-in",
    "relUrl": "/projects/proj4/#what-to-turn-in"
  },"24": {
    "doc": "Project 4",
    "title": "Reminders",
    "content": ". | Do not forget to comment your code. | . ",
    "url": "/cs142-f22/projects/proj4/#reminders",
    "relUrl": "/projects/proj4/#reminders"
  },"25": {
    "doc": "Project 4",
    "title": "Challenges",
    "content": ". | You may notice that all of the sample mazes provided have exactly one solution. That is, there is one path from where Harry starts to the cup. Therefore, your recursive code doesn’t need to handle the situation where it may have to decide which of two possible paths is better/faster/quicker/shorter. Develop a version of your code that will work with mazes with multiple solutions, and find the shortest one. To do this, try copying one of the larger maze files and deleting a few walls. This will open up multiple paths to the solution. | . ",
    "url": "/cs142-f22/projects/proj4/#challenges",
    "relUrl": "/projects/proj4/#challenges"
  },"26": {
    "doc": "Project 4",
    "title": "Project 4",
    "content": " ",
    "url": "/cs142-f22/projects/proj4/",
    "relUrl": "/projects/proj4/"
  },"27": {
    "doc": "Project 3",
    "title": "CS 142 Project 3: Animation Exploration",
    "content": ". | Starter code | Guide to the classes | Guide to the math | How to develop the project . | The Polygon class | The ComboPolygon class | The TranslationAnimation class | The RotationAnimation class | The AnimationSequence class | . | What to turn in | Challenges | . For this project, you will write a program that allows you to model polygons and animations in an object-oriented style. The end result will be a collection of classes that, when put together, allows you to build animations on the screen out of polygons that move in certain ways at certain times, like this: . Your browser does not support the video tag. The final product will be creating the above animation (or something comparable) programmatically, using classes that you design. Along the way you will create other simpler animations. ",
    "url": "/cs142-f22/projects/proj3/#cs-142-project-3-animation-exploration",
    "relUrl": "/projects/proj3/#cs-142-project-3-animation-exploration"
  },"28": {
    "doc": "Project 3",
    "title": "Starter code",
    "content": "Make sure you create the project in a place on your computer where you can find it! I suggest making a new subfolder in your CS 142 projects folder. You can download the starter code for this assignment by creating a new IntelliJ project from version control (VCS) and using the following URL: . https://github.com/pkirlin/cs142-f22-proj3 . ",
    "url": "/cs142-f22/projects/proj3/#starter-code",
    "relUrl": "/projects/proj3/#starter-code"
  },"29": {
    "doc": "Project 3",
    "title": "Guide to the classes",
    "content": "In this project, you will design a number of classes that represent polygons, groups of polygons, and animations of these polygons. The classes you will write are: . | Polygon: A polygon represents a shape drawn with a sequence of connected line segments. Each polygon is defined by a sequence of (x, y) points, and the boundary of the polygon is formed by connecting the points in sequence. For instance, a triangle Polygon would have three points, a rectangle four, etc. A Polygon also knows what color it is so it can be drawn on the canvas. Polygons also have the ability to be translated and rotated: . A translation is simply changing the location of the polygon; it is shifted a certain amount in the x direction and a certain amount in the y direction. This does not change the polygon’s overall shape, size, or orientation. A rotation means rotating the polygon around a fixed point, which does not have to be part of the polygon itself. This changes the location of the polygon, but also might change its orientation. Its shape and size are not changed. | ComboPolygon: A “combo polygon” represents a collection of Polygon objects that form some combined shape that should be treated as one unit. They also have the ability to be translated and rotated: when a translation or rotation is applied to a ComboPolygon that operation is simply passed along to each Polygon that makes up the ComboPolygon. | TranslationAnimation and RotationAnimation: These two classes represent a translation or rotation animation applied to a specific ComboPolygon. These classes store information about how an animation takes place over time, in that both classes store a time (in milliseconds) that the animation starts, and a time that the animation ends. In this way, one can represent, for instance, a 90-degree rotation that begins at time 1000ms and ends at time 3000ms (for an animation that lasts 2 seconds in total). | AnimationSequence: This class represents a collection of animations applied to various ComboPolygons. Each animation may be a translation or rotation, and can begin and end at any time. This class is in charge of playing the animations at the appropriate times so they all are timed correctly and animate appropriately. | . ",
    "url": "/cs142-f22/projects/proj3/#guide-to-the-classes",
    "relUrl": "/projects/proj3/#guide-to-the-classes"
  },"30": {
    "doc": "Project 3",
    "title": "Guide to the math",
    "content": "This project requires some understanding of translations and rotations in geometry and how they are applied to a polygon. Translations are straightforward. A translation means moving every point in a polygon a fixed distance in the x direction, and a fixed distance in the y direction. The distances in the x and y directions need not be the same, and they may be zero (for instance, to shift the polygon perfectly left, right, up or down). Mathematically, just add the translation’s x distance and y distance to each point in the polygon. Note that in computer graphics, the y-axis is “flipped”, so a translation of 10 in the y-direction increases all the y coordinates in the polygon by 10, and therefore moves the polygon down the screen. Rotations are more complicated. Our rotations are defined by an angle measured in degrees, along with an (x, y) point that we will rotate around. The point is required information because rotating, for instance, a square 90 degrees around its center point does not change the square in any visible way (see the red square below), but rotating the same square around one of its corners shifts its location on the screen (see the blue square, which is rotating around its lower-left corner). Your browser does not support the video tag. To rotate a polygon around a point, we will apply the steps below to each point of the polygon. To rotate a point of a polygon \\((x, y)\\) around another point \\((a, b)\\) by some angle \\(t\\), do the following: . | Assuming the angle \\(t\\) is in degrees, is must be converted into radians. Do this by multiplying \\(t\\) by \\(\\pi/180\\). | Translate \\((x, y)\\) by \\((-a, -b)\\). That is, subtract \\(a\\) from \\(x\\) and \\(b\\) from \\(y\\). | Set \\(x_2 = x \\cdot \\cos(t) - y \\cdot \\sin(t)\\). | Set \\(y_2 = x \\cdot \\sin(t) + y \\cdot \\cos(t)\\). | Translate \\((x_2, y_2)\\) by \\((a, b)\\). That is, add \\(a\\) to \\(x_2\\) and \\(b\\) to \\(y_2\\). | The new rotated point is \\((x_2, y_2)\\). | . ",
    "url": "/cs142-f22/projects/proj3/#guide-to-the-math",
    "relUrl": "/projects/proj3/#guide-to-the-math"
  },"31": {
    "doc": "Project 3",
    "title": "How to develop the project",
    "content": "This project is organized around writing one class at a time and testing it. Unlike previous projects, there is no specific main() method to write; rather there is a file called Tests.java that you will use to write tests for each class as you develop them, and also contains a final animation that should reproduce the video above. The guide below indicates the required tests you must write, but you should feel free to add more! . The Polygon class . This class already has the instance variables and a few methods written for you. The way this class is supposed to work is that the constructor is provided with the number of points the polygon will eventually contain, and the color of the polygon. However, the actual coordinates of the points aren’t provided in the constructor, they will be added through calling the addPoints() function. Note: The points of a polygon are represented here as doubles, even though we will only ever have use integer coordinates. The reason for this is that when we start animating the polygons, it is possible that the translation and rotation math will require some polygons to temporarily be placed at non-integer coordinates, so therefore we just store all points as doubles. Example usage of this class: . Polygon rectangle = new Polygon(4, Color.RED); rectangle.addPoint(100, 100); rectangle.addPoint(200, 100); rectangle.addPoint(200, 300); rectangle.addPoint(100, 300); . Because we are storing the x and y coordinates in arrays, when a new point is added to the polygon, we have to know what index in these arrays the point should go into. This is maintained through the nextIndex variable. Notice how in the constructor, nextIndex is initialized to zero. Whenever addPoint() is called, it should place the new x and y coordinates (that it is given as parameters) into the xpoints and ypoints arrays at the index nextIndex. Then it should increment nextIndex so that the next call to addPoint() will put its points into the array one index to the right. You do not have to check for addPoints() being called too many times, though you may. Suggested order of writing methods . Before writing any methods, familiarize yourself with the instance variables of the class and envision how the methods will work with them. Note that the constructor and the drawOn() method are already written for you. | addPoint(): Write this first. This method takes a new (x, y) point to add to the polygon. | toString(): Write this next. This method should return a String starting with the word Polygon:, and then be followed by all the points of the polygon. You can include the color of the Polygon if you want. Remember, this method should return the String, not print it. Hint: Use Arrays.toString() to turn an array into a String. | Stop and test. In Tests.java, run testPolygons(). This test function creates a red rectangle, prints it out, and displays it on a sample canvas. The polygon’s string representation should be something like: . Polygon: [100.0, 200.0, 200.0, 100.0] [100.0, 100.0, 300.0, 300.0] . The canvas should look like this: . Then, create a second polygon in the test function, print it out, and draw it on the canvas. Verify that it is printed and drawn correctly. | translate(): Write this next. This method takes two doubles, distx and disty, and should translate the polygon by these distances in the x and y directions. Note: This has nothing to do with the animations; these translations should happen “instantly” when the method is called. | Stop and test. In Tests.java, comment out the call to testPolygons() in main(), and uncomment the call to testTranslation() This test function creates a red rectangle, prints it out, then translates it twice, and prints it out after each translation. The output should be: . Polygon: [100.0, 200.0, 200.0, 100.0] [100.0, 100.0, 300.0, 300.0] Polygon: [110.0, 210.0, 210.0, 110.0] [120.0, 120.0, 320.0, 320.0] Polygon: [80.0, 180.0, 180.0, 80.0] [80.0, 80.0, 280.0, 280.0] . The test function also asks you to create a second polygon and test its translation. | rotateAround(): Write this next. This method takes a point and an angle (in degrees) and should rotate the polygon around the given point by the specified number of degrees. Follow the math above to write this method, adjusting each point of the polygon. Note that if degrees is positive, the rotation is clockwise, and if its negative, the rotation is counter-clockwise. (This happens automatically with the math, you don’t have to do anything special for this.) . | Stop and test. In Tests.java, write a function called testRotations() that works similarly to testTranslations(). You should create a polygon and rotate it a few times, and verify the rotations work as they should. You can make up examples or find some online (there are lots of videos that walk through the math, and you can use their examples if you don’t want to make up your own.) . An alternate way to test is to test the rotations on a canvas. In your testRotations() function, you can create a polygon, display it on a canvas with drawOn(), wait for a mouse click (or pause the canvas), rotate the polygon, then re-display it on the same canvas with another call to drawOn(). Don’t forget to call update() on the canvas after the rotation to get the picture to change. You can also call clear() on the canvas to erase it before displaying the rotation, or leave it out to display the pre-rotation and post-rotation images. | . Polygon is now done! . The ComboPolygon class . This class is left mostly blank, but the implementation of a ComboPolygon is very similar to regular Polygons, in that their job is mostly to manage arrays. A Polygon manages two arrays of doubles, while a ComboPolygon will manage a single array of Polygons. Notice how the instance variables in ComboPolygon parallel a few of the instance variables in Polygon, and how similar the constructors are. Most of the methods in this class simply “pass along” their commands to each individual polygon within the ComboPolygon. For instance, how do you translate a ComboPolygon? You simply call translate with the same arguments on each individual Polygon in the polys array. Same with rotateAround() and drawOn(). Suggested order of writing methods . | addPolygon(): Write this first. This method takes a new Polygon to add to the ComboPolygon. This is just like addPoint() in Polygon. | toString(): Write this next. This method can simply return whatever Arrays.toString() returns for the polys array. Remember, this method should return the String, not print it. | Stop and test. In Tests.java, run testComboPolygons(). This test function creates a combination polygon of four differently-colored squares and prints it out. The drawing won’t work yet because we haven’t written drawOn(), but if you’ve written toString() correctly, you should see something like: . ComboPolygon: [Polygon: [140.0, 180.0, 180.0, 140.0] [140.0, 140.0, 180.0, 180.0], Polygon: [180.0, 220.0, 220.0, 180.0] [180.0, 180.0, 220.0, 220.0], Polygon: [180.0, 220.0, 220.0, 180.0] [140.0, 140.0, 180.0, 180.0], Polygon: [140.0, 180.0, 180.0, 140.0] [180.0, 180.0, 220.0, 220.0]] . | drawOn(): Write this next. Use a for loop to call drawOn() on each Polygon in the ComboPolygon, passing along the same arguments the method was called with. | Stop and test. At this point, you should be able to see the ComboPolygon drawn on the screen while testing. | translate(): Write this next. Use a for loop to call translate() on each Polygon in the ComboPolygon, passing along the same arguments the method was called with. | Stop and test. In Tests.java, either add some code in testComboPolygons() to test the translation method, or write a new test function. | rotateAround(): Use a for loop to call rotateAround() on each Polygon in the ComboPolygon, passing along the same arguments the method was called with. | Stop and test. In Tests.java, either add some code in testComboPolygons() to test the rotation method, or write a new test function. | . ComboPolygon is now done! . The TranslationAnimation class . This class manages an animation of a translation, which is formed by splitting a single translation into pieces that take place over time. First, a quick tutorial about how animation works. Motion in TV and film is of course, an illusion. Videos that appear to display moving pictures are actually displaying a sequence of images, called “frames,” very quickly in sequence, where each frame contains a still image. By making sure the images differ from each other only minimally, and by only pausing for a fraction of a second while displaying each frame, our eyes interpret the sequence of non-moving images as moving pictures. (More info.) . Typically, our eyes can only perceive 10-12 frames per second as visually distinct, whereas anything faster is perceived as motion. Various video and TV standards typically use somewhere between 24-60 frames per second. (More info.) Our animations, to make the math easier, will use 50 frames per second, which means each frame of our animations will be displayed for 1/50th of a second, which is 20 milliseconds (ms). Here’s a full example. Suppose we wish to translate the point (100, 100) by 100 pixels in the x direction and 200 pixels in the y direction, and this animation should last 2 seconds (2000ms). (Note that this example uses a single point, but all the math can be extrapolated to apply to a Polygon or ComboPolygon). Because the animation lasts 2000ms, and each frame of the animation will be displayed for 20ms, we know that there are 100 total frames in the animation. Now we have to figure out how much each frame changes from the previous one. To do this, we divide up the total distance of the translation (separately for x and y) over each frame. So the x coordinate is changing by 100 pixels over 100 frames, so the point moves one pixel in the x direction for each frame. Similarly, the y coordinate is changing by 200 pixels over 100 frames, so the point moves two pixels in the y direction for each frame. In this way, the total translation is divided into 100 mini-translations, each one moving the polygon by 1 pixel in the x direction and 2 pixels in the y direction. All of this information is stored and managed in the TranslationAnimation class. In particular, this class maintains variables to store the total change in the x and y directions, the time the animation starts and ends, and the ComboPolygon the animation is run on. Note that start and end times are used rather than a single “duration” so that later on we can have animations start at different times. Suggested order of writing methods . | Write advanceToNextFrame() first. This method should calculate the individual x and y distances for one frame of animation and then call your translation function you wrote earlier to make the change. | Stop and test: Fill in the testTranslationFrames() test code in Tests.java to test your advanceToNextFrame() method. Code is already written for you that creates a very small test animation that mirrors the example given above. You should add code to advance the ComboPolygon to the next frame a few times, and print it out after each advancement. Make sure the points of the polygon are being translated correctly. | Now write playOn(). This method displays the full animation, frame by frame, on a canvas. There is pseudocode in the method to follow. There is already a test function written: testTranslationAnimation(). The final result should be this: . | . Your browser does not support the video tag. The RotationAnimation class . This class mirrors the TranslationAnimation class, but is for rotations instead. Everything from above applies here; the only difference is that instead of having a translation x distance and y distance to divide into a certain number of frames, we have a rotation angle that needs to be divided instead. So write this class following the model above. When you’re all done, you should be able to run testRotationAnimation() and see the following: . Your browser does not support the video tag. The AnimationSequence class . This class is the last class! It manages a collection of translation and rotation animations, each one running at different times. Suggested order of writing methods . | Write addTranslation() and addRotation() first. These should add a TranslationAnimation or RotationAnimation to the appropriate array. | Write getMaxTime() next. This should examine all the animations in the class and return the maximum ending time. This is therefore the total length of the entire animation sequence. | Write playOn() last. This is the final method of the project! This method should act similarly to the playOn() methods in the animation classes, but it can’t just call them directly. The reason is because we need the animations to all run simultaneously if they overlap in time. So the strategy to use here is to write a loop, similar to the ones in the animation classes that iterates through the a time variable by 20 millisecond increments. Then, inside that loop, we will have two other loops that iterate through the translation animations and the rotation animations, checking each one to see if we should advance to the next frame of the animation. Follow the pseudocode in the method. | When you’re all done, you should be able to run the testFullAnimation() test case, and it should reproduce the video at the top of this project. | . ",
    "url": "/cs142-f22/projects/proj3/#how-to-develop-the-project",
    "relUrl": "/projects/proj3/#how-to-develop-the-project"
  },"32": {
    "doc": "Project 3",
    "title": "What to turn in",
    "content": ". | Through Canvas, turn in all your .java files. Additionally, upload a text file answering the following questions: | . | What bugs and conceptual difficulties did you encounter? How did you overcome them? What did you learn? | Describe whatever help (if any) that you received. Don’t include readings, lectures, and exercises, but do include any help from other sources, such as websites or people (including classmates and friends) and attribute them by name. | Describe any serious problems you encountered while writing the program. | Did you do any of the challenges (see below)? If so, explain what you did. | List any other feedback you have. Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it. | . ",
    "url": "/cs142-f22/projects/proj3/#what-to-turn-in",
    "relUrl": "/projects/proj3/#what-to-turn-in"
  },"33": {
    "doc": "Project 3",
    "title": "Challenges",
    "content": ". | Add other types of animations, such as growing or shrinking a polygon (scaling it up or down), or a combination translation/rotation animation that does both at the same time (this would be necessary, for example, for an animation of a bicycle wheel that rolls along the ground, because it is simultaneously rotating and being translated). | Create an animation of your choice, similar in complexity to the full animation at the end of this project. Points will be given for creativity and complexity! . | . ",
    "url": "/cs142-f22/projects/proj3/#challenges",
    "relUrl": "/projects/proj3/#challenges"
  },"34": {
    "doc": "Project 3",
    "title": "Project 3",
    "content": " ",
    "url": "/cs142-f22/projects/proj3/",
    "relUrl": "/projects/proj3/"
  },"35": {
    "doc": "Project 2",
    "title": "CS 142 Project 2",
    "content": ". | Game description | Starter code | Guide to the project | Functions you will write | Testing your program | What to turn in | Challenges | Hints and tips | Other games | . You will write a program that allows the user to play a “Candy Crush Saga”-style game that we are calling “Gumdrop Gatherer.” (Let me know if you can come up with a better name for this…) In the game, you are presented with a two-dimensional grid of gumdrops, and you must gather them in a certain way to collect as many points as possible. You can use the mouse to click on any gumdrop you want, as long as it has at least one neighboring gumdrop of the same color. At that point, all the gumdrops of that color are neighbors of the one you selected (and neighbors of the neighbors, etc) disappear, and new ones drop from the top to take their place. You earn points for every gumdrop that disappears. Alternate games . If this game doesn’t particularly interest you, you may create any two-dimensional game of your choice of comparable programming difficulty. See the end of this document for requirements and suggested games. You must get the instructor’s approval before starting work on your project if you are not writing the Gumdrop Gatherer program. ",
    "url": "/cs142-f22/projects/proj2/#cs-142-project-2",
    "relUrl": "/projects/proj2/#cs-142-project-2"
  },"36": {
    "doc": "Project 2",
    "title": "Game description",
    "content": "A video is worth a thousand words, so let’s take a look at a demonstration. Your browser does not support the video tag. Your game doesn’t have to work exactly like mine, but it must meet the following requirements: . | The game should ask the user how big the board should be, in rows and columns. | The game should ask the user how many points to play to. | The game should draw a board of the specified size, filled with colored circles representing gumdrops. I find that using four different colors for gumdrops works well. | The game should let the user click the gumdrops (the colored circles). With every click, the program should check if the gumdrop clicked on has at least one neighbor (upper, lower, left, or right) of the same color. If it does, then all gumdrops connected to the original one of the same color should disappear. Here, “connected” means a neighbor of the same color, or neighbors of neighbors of the same color, or neighbors of neighbors of neighbors, etc. In other words, the single entire region of the same color should disappear. “Neighbors” means left, right, above, or below, not diagonal. | When a region of gumdrops disappears, if there are any gumdrops above the region, then they should fall as far as they can downward, until they hit other gumdrops in the same column (simulating gravity). | Once all the gumdrops have fallen down, there will still be open areas of the board. These should be filled with new gumdrops. (You do not have to simulate gravity to have the new gumdrops “fall in” from off the top of the screen; they can just appear.) | 10 points are accumulated for each gumdrop eliminated in a region. For example, if you eliminate 3 gumdrops at once, that earns 30 points. However, bonuses are given for larger regions of gumdrops eliminated at once. For regions at least 5 gumdrops big, each gumdrop earns 50 points. So a region of 5 gumdrops all disappearing at once earns 250 points. For regions at least 10 gumdrops big, you earn 100 points per gumdrop. For instance, if you can eliminate 10 gumdrops at once, that earns 1000 points! | When you reach the threshold for points entered at the beginning of the program, the game ends. | . ",
    "url": "/cs142-f22/projects/proj2/#game-description",
    "relUrl": "/projects/proj2/#game-description"
  },"37": {
    "doc": "Project 2",
    "title": "Starter code",
    "content": "Make sure you create the project in a place on your computer where you can find it! I suggest making a new subfolder in your CS 142 projects folder. You can download the starter code for this assignment by creating a new IntelliJ project from version control (VCS) and using the following URL: . https://github.com/pkirlin/cs142-f22-proj2 . In the starter project you will find three files: . | GumdropGatherer.java is where you will write your code. A few methods are already written for you. | SimpleCanvas.java is the SimpleCanvas code that you don’t need to worry about. | BouncingBall.java is a demonstration on using the pause() method in SimpleCanvas to make an animation. You will probably want to use pause() when you start implementing the gravity part of the project, so you can use this as an example. | . ",
    "url": "/cs142-f22/projects/proj2/#starter-code",
    "relUrl": "/projects/proj2/#starter-code"
  },"38": {
    "doc": "Project 2",
    "title": "Guide to the project",
    "content": "This project is set up similarly to the Tic-Tac-Toe lab. The starter code uses a number of familiar functions, including handleMouseClick() and draw(). Representing a gumdrop board . The gumdrop board will be represented as a 2D array of integers (int[][]), unlike the tic-tac-toe board, which was a 2D array of characters (char[][]). While you could use chars, I think integers are easier because it allows us to represent the gumdrops on the board like this: . | If board[row][col] contains a zero, it means that square on the board is empty. | If board[row][col] contains an integer 1–4 (inclusive), that means that square contains a gumdrop. The specific number 1–4 corresponds to the color of the gumdrop (you can pick the colors; I used red/green/blue/yellow). | If board[row][col] contains a negative integer 1–4, that means that square contains a marked gumdrop. Marked gumdrops are ones that are about to be removed, and are drawn in white. (This concept is explained more in-depth later.) | . In other words, just like the tic-tac-toe lab used chars to represent the empty spaces, X’s, and O’s on the board, we will use ints in a similar way: zero = empty space, positive numbers = gumdrops, negative numbers = “marked” gumdrops. Drawing the board on the canvas In tic-tac-toe we used a square size of 100-by-100 because the game board was only 3 by 3, which then scaled up to a 300 x 300 sized canvas. Because the game board for this project can be larger (it’s more fun if it’s larger), I suggest using a gumdrop size of 40-by-40 instead. In other words, instead of multiplying and dividing by 100, you will multiply and divide by 40. Marking gumdrops for removal . When a gumdrop is clicked on, we need to figure out the region of gumdrops that will be removed. The way we will do this is by “marking” gumdrops for removal in an iterative process. When a gumdrop is first clicked on, your code should change its number to its negative equivalent. Remember that the gumdrop colors are stored internally by positive integers 1–4. So when a gumdrop is clicked on, it will be marked for removal by changing its integer to the corresponding negative integer. That is, “1” becomes “-1”, “2” becomes “-2”, etc. Finding the region of gumdrops to remove . Remember that when a gumdrop is clicked, the entire contiguous region of gumdrops connected to the initially-clicked gumdrop should be removed. This will be done in two phases. First, we will find the region of gumdrops to be removed by “spreading” the marked gumdrop (now a negative number) to all neighboring gumdrops above, below, left, and right that are the same color as the marked gumdrop. We do this over and over again, as long as there are more gumdrops to mark. Note that this iterative spreading process is not shown visually; the user should only see the final result after the spreading can’t go any farther. ",
    "url": "/cs142-f22/projects/proj2/#guide-to-the-project",
    "relUrl": "/projects/proj2/#guide-to-the-project"
  },"39": {
    "doc": "Project 2",
    "title": "Functions you will write",
    "content": ". | The game begins in the main() method, like all Java programs. There are instructions there explaining the general algorithm. To be clear, you should not write all of your code inside main()! | I’ve given you the function definitions for two other functions: handleMouseClick and draw. I’ve also given you a useful function for debugging, printBoard, that prints the board in text. This is useful for debugging. | You must write a few other functions as well. This will help you split the project into manageable pieces: . | hasMatchingNeighbor(int[][] board, int row, int col): This function returns a boolean indicating whether or not the gum drop at (row, col) has a neighboring gumdrop of the same color. This function will be used in handleMouseClick to detect if a gumdrop that the player clicked on has a matching neighbor of the same color. If there isn’t a matching neighbor, the function will return false, and the game won’t allow the user to select that gumdrop. | spreadMarked(int[][] board): After “marking” the initial gumdrop by switching the number of the gumdrop to its negative value, this function should “spread” the negative value by checking all the neighbors (up/down/left/right) of any marked gumdrop and marking neighbors with the matching number (color). This can be called in a loop until no more marking happens. Hints are below. | removeMarked(int[][] board): After all the gumdrops needing to be marked are marked, I used this function to remove them (turn the negative numbers into zeroes). Remember, gumdrops are never “truly” removed, we just turn them back into zeroes which indicates empty squares. | gravity(int[][] board): After removing marked gumdrops, I used this function to iteratively lower any “floating” gumdrops until they were resting on top of existing ones. | calcPoints(int gumdrops): I used this function to calculate how many points the player earns for removing however many gumdrops they removed. | fillEmptySqures(int[][] board): I used this function after removing marked gumdrops to place new random gumdrops in the empty squares. | . | . You may determine the proper parameters and return values for these functions. Javadoc comments . In Lab 2, we learned about Javadoc comments. You should place Javadoc comments before any function you write in this project. There are examples in the starter code. ",
    "url": "/cs142-f22/projects/proj2/#functions-you-will-write",
    "relUrl": "/projects/proj2/#functions-you-will-write"
  },"40": {
    "doc": "Project 2",
    "title": "Testing your program",
    "content": "You should test your program thoroughly to make sure it works. You will do this by writing “test functions.” A test function is a function designed to test a different function, that will run a number of test cases on the function being tested. You can call these test functions from main. You must write test functions for hasMatchingNeighbor(), gravity() and spreadMarked(). Additional test functions are highly recommended, but not required. For instance, to test gravity(), you might write this: . public static void testGravity() { int[][] board1 = { {1, 3, 2, 1}, {1, 0, 0, 3}, {2, 2, 0, 0}, {0, 0, 0, 1} }; gravity(board1); printBoard(board1); } . And then you would verify that your test code prints . [0, 0, 0, 0] [1, 3, 2, 1] [1, 0, 0, 3] [2, 2, 0, 1] . ",
    "url": "/cs142-f22/projects/proj2/#testing-your-program",
    "relUrl": "/projects/proj2/#testing-your-program"
  },"41": {
    "doc": "Project 2",
    "title": "What to turn in",
    "content": ". | Through Canvas, turn in your GumdropGatherer.java file. Additionally, upload a text file answering the following questions: | . | What bugs and conceptual difficulties did you encounter? How did you overcome them? What did you learn? | Describe whatever help (if any) that you received. Don’t include readings, lectures, and exercises, but do include any help from other sources, such as websites or people (including classmates and friends) and attribute them by name. | Describe any serious problems you encountered while writing the program. | Did you do any of the challenges (see below)? If so, explain what you did. | List any other feedback you have. Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it. | . ",
    "url": "/cs142-f22/projects/proj2/#what-to-turn-in",
    "relUrl": "/projects/proj2/#what-to-turn-in"
  },"42": {
    "doc": "Project 2",
    "title": "Challenges",
    "content": ". | Add additional functionality to the game like you might find in games like Candy Crush Saga, Angry Birds, Toon Blast, etc. | For example, make up different kinds of “items” that can appear in squares on the board. Like a bomb that explodes neighboring squares, or a present that earns you bonus points. | Make the same-color-neighbor concept work with diagonal directions (so regions can extend diagonally as well as horizontally or vertically). | . ",
    "url": "/cs142-f22/projects/proj2/#challenges",
    "relUrl": "/projects/proj2/#challenges"
  },"43": {
    "doc": "Project 2",
    "title": "Hints and tips",
    "content": ". | Checking to see if a gumdrop is next to one of the same color This is a slightly tricky one because it involves checking the neighboring squares on the game board. What makes it tricky is that if the gumdrop is on the border of the board, then all four neighbors (up, down, left, right) may not exist. | Finding the region of gumdrops that should disappear when one is clicked . In the demo video above, we use the color white to show the gumdrops that are about to disappear. To make this happen, we will use a negative numbers to represent these gumdrops. When a user clicks on a gumdrop, first check if the gumdrop has a neighbor of the same color. If there is a same-colored neighbor, change the gumdrop from whatever number it is to its negative version (so change 1 to -1, 2 to -2, etc). This indicates that it will disappear. Then we will “spread” these negative numbers to all neighboring gumdrops that have the same color as the original one (match in number). Try writing this function: . boolean spreadMarked(int[][] board): This function should “spread” any negative numbers s in the board to their upper, lower, left, and right neighbors, if those neighbors have the same number as the negative number in question. This sounds harder than it is. To do this, use a standard nested-for loop to iterate through the board. Whenever you find a negative number, first check to see if any of the four neighbors have the positive version of that number in them. If they do, overwrite the neighbor with the negative number. I suggest having this function return true whenever at least one cell was changed; that way you can call this function repeatedly until it returns false (indicating the negative region can’t get any larger). Examples: . Imagine a board like this: . board = { {4, 3, 2, 1}, {1, 4, 3, 3}, {2, 4, 4, 4}, {3, 4, 4, 1} }; . Imagine the user clicks on the gumdrop at row 2 and column 1. First, we have Java do the command board[2][1] *= -1 which changes the board to this: . board = { {4, 3, 2, 1}, {1, 4, 3, 3}, {2, -4, 4, 4}, {3, 4, 4, 1} }; . Then we call spread(board) which changes the board to this: . board = { {4, 3, 2, 1}, {1, -4, 3, 3}, {2, -4, -4, 4}, {3, -4, 4, 1} }; . The function call above will return true, meaning at least one square was changed. Notice how the -4 has spread to three additional squares. Then we call spreadMarked(board) again. Now the board changes to: . board = { {4, 3, 2, 1}, {1, -4, 3, 3}, {2, -4, -4, -4}, {3, -4, -4, 1} }; . and the function call returns true, since we changed two more 4s into -4s. Then we would spreadMarked(board) one more time, but the board wouldn’t change, because there are no more 4s to change into -4s. Note that the 4 in the upper left corner doesn’t change to -4 because it’s not directly next to any of the -4s. So the function returns false (and we can therefore stop calling it). | Replacing the negative numbers with 0s . You can write a simple function that replaces all the negative numbers with zeros. The only reason the negatives are there in the first place was so we can draw them in white for a split second and then remove them from the board by replacing them with zeros. I called my function removeMarked. I also had it return the number of negative numbers replaced by zeroes, which I then used to assign the points that the user earned. | Simulating gravity . This, along with the spreadMarked function, are the two most challenging parts of the program. I suggest writing a function called gravity that goes through every square of the board and looks for a situation where there is a square with a number in it, and a square with a zero below it. The 0 indicates a blank space, so the number should be lowered into the blank space (where the zero is now), and the number replaced with a zero. This simulates gravity dropping each gumdrop into the square below. Like the function above, have the gravity function return true if any gumdrops were moved. That way, you can call gravity over and over in a loop until it returns false (which means all of the gumdrops have been lowered into their final positions). To write this function, use the standard nested for loops, but have the row loop run backwards, to examine the rows from the bottom up. Examples: . Imagine a board like this: . board = { {1, 3, 2, 1}, {1, 0, 0, 3}, {2, 2, 0, 0}, {0, 0, 0, 1} } . After calling gravity(board), the board will look like: . board = { {0, 0, 0, 0}, {1, 3, 2, 1}, {1, 0, 0, 3}, {2, 2, 0, 1} } . and the function returns true`, because at least one number moved. We can then call gravity(board) again to get: . board = { {0, 0, 0, 0}, {1, 0, 0, 1}, {1, 3, 2, 3}, {2, 2, 0, 1} } . and the function returns true. We call it one more time: . board = { {0, 0, 0, 0}, {1, 0, 0, 1}, {1, 3, 0, 3}, {2, 2, 2, 1} } . and it returns true. At this point all the pieces are as low as possible, but the function must be called one more time to return false in order to determine that. | . ",
    "url": "/cs142-f22/projects/proj2/#hints-and-tips",
    "relUrl": "/projects/proj2/#hints-and-tips"
  },"44": {
    "doc": "Project 2",
    "title": "Other games",
    "content": ". | If you don’t like this game, you can make a different one. The requirements are that it must involve a customizable-size board, and it must involve some concept where you examine the “neighbors” of the squares on the board. | Some ideas are: Minesweeper, Connect 4, 2048, Candy Crush, Angry Birds, … | You must clear your idea with me first. | . ",
    "url": "/cs142-f22/projects/proj2/#other-games",
    "relUrl": "/projects/proj2/#other-games"
  },"45": {
    "doc": "Project 2",
    "title": "Project 2",
    "content": " ",
    "url": "/cs142-f22/projects/proj2/",
    "relUrl": "/projects/proj2/"
  },"46": {
    "doc": "Project 5",
    "title": "CS 142 Project 5: Ladybug Dance Party",
    "content": ". | Starter code | Concepts in this program . | Enumerated types | The DancingBug class | The DanceFloor class | The LeaderBug interface | . | A sample dancing bug | Implementing the project . | DanceTester | SpinBug | RoutineBug | SquareBug | LeaderBug | ImitationBug | A second ImitationBug | MirrorBug | CongaBug | main() function | . | What to turn in | Challenges | . In this assignment, you will be creating a graphical animation of a ladybug dance party. There can be lots of different kinds of dancers at the party–but since they all share some characteristics (e.g., they are all dancing bugs), you can use inheritance to easily create the program and avoid code duplication. A sample dance party is below: . Your browser does not support the video tag. ",
    "url": "/cs142-f22/projects/proj5/#cs-142-project-5-ladybug-dance-party",
    "relUrl": "/projects/proj5/#cs-142-project-5-ladybug-dance-party"
  },"47": {
    "doc": "Project 5",
    "title": "Starter code",
    "content": "Make sure you create the project in a place on your computer where you can find it! I suggest making a new subfolder in your CS 142 projects folder. You can download the starter code for this assignment by creating a new IntelliJ project from version control (VCS) and using the following URL: . https://github.com/pkirlin/cs142-f22-proj5 . ",
    "url": "/cs142-f22/projects/proj5/#starter-code",
    "relUrl": "/projects/proj5/#starter-code"
  },"48": {
    "doc": "Project 5",
    "title": "Concepts in this program",
    "content": "You will mainly be practicing with inheritance, polymorphism, and abstract classes in this project. Enumerated types . In Java, an enumerated type (called an enum) is a special kind of data type (like a class), but only allows for variables of that type to be set to a pre-defined range of constants. So it’s good for situations where you want a variable to be set to one of only a small number of possible choices. We use two enums in this project: Directions and DanceSteps. Open up those files and take a look at them. You don’t need to really understand the syntax, but just know that whenever you define a Direction variable, it must be set to one of Direction.NORTH, Direction.SOUTH, Direction.EAST, and Direction.WEST. There are no other possible directions, which makes sense. The direction enum also has some instance variables and methods, but you will most likely not have to know about them or call them. Similarly for the DanceStep class, a DanceStep variable may only be set to one of the seven possible dance steps listed in that class. The DancingBug class . (You should follow along in the DancingBug class as you read this explanation.) . The DancingBug class is the base class from which all dancing bugs must derive. Note that a DancingBug has a location (row &amp; column), a direction the bug is facing, and a color. (Note that colors in this project are just strings, and should be one of the colors you are given the image files for: red, blue, green, gray, pink, orange, brown, or purple). Pay special attention to the step() method in DancingBug. It is marked as abstract, which we know means that all classes that inherit from DancingBug must write this method. The step() method must perform one step of a dance, probably by calling the doStep() method with the name of the dance step desired. In particular, you should probably not have a bug take multiple dance steps inside the step() method, only because those steps will be collapsed into a single step in the graphical output. The DanceFloor class . (You should follow along in the DanceFloor class as you read this explanation.) . The DanceFloor class represents the grid where the bugs dance, though you don’t have to pay too much attention to this class. All you really need to know is you can call addDancer() to add a bug to the dance floor, removeDancer() to remove one, and everyoneDance() starts the dance party. Note that the stepAll() function simply calls step() on each bug to have them take whatever dance step is next. You should not need to modify these functions except if you need/want to add print statements for debugging. The LeaderBug interface . Normally, Java subclasses may only inherit from a single superclass. Some programming languages allow multiple inheritance (where one subclass may have multiple superclasses, but Java is not one of them). However, Java supports another concept, called interfaces, which are useful when a class needs to have a specific parent class, but also needs to define some methods that relate to a second concept. In Java, interfaces are like abstract classes, except every method is abstract. No method bodies are allowed in interfaces. No instance variables are allowed either. An interface is solely a contract saying that “whatever class implements this interface must define these methods.” In this project, there is an interface called LeaderBug, that defines an (abstract) method called getLastStep(). This interface will be used when we want to define a type of bug that can “lead” a series of dance steps and have other bugs follow along. A bug that wants to follow the dance steps of another bug can look for Bug objects that have a getLastStep() function and call that function to copy what the other bug (the leader did). But because every bug must derive from DancingBug, and DancingBug doesn’t have a getLastStep() function, we have to tell Java that leader bugs have something else in common, and this is done through implementing an interface. (This will make more sense when you get to that problem.) . ",
    "url": "/cs142-f22/projects/proj5/#concepts-in-this-program",
    "relUrl": "/projects/proj5/#concepts-in-this-program"
  },"49": {
    "doc": "Project 5",
    "title": "A sample dancing bug",
    "content": "Open BoredBug.java. Notice the BoredBug constructor, which allows someone to specify the row &amp; column where a BoredBug should be. The constructor calls the superclass constructor, passing in row &amp; col, and also that the bug should be gray. Look at the step() method. A BoredBug simply does nothing; it stands around on the dance floor looking bored. So the step() method just calls doStep(DanceStep.PAUSE), which you can probably guess doesn’t do anything. In fact, we could have left this method empty, but this illustrates how to use the doStep() function. Now open DanceTester.java. Notice how the testBoredBug method makes a small dance floor, adds a BoredBug to it, and then starts the dance party. Run the code, and you should see the dance floor appear. Click it, and the bug will start “dancing” (you should see it printing info about itself, though obviously the bug doesn’t move because its step() method doesn’t do anything). ",
    "url": "/cs142-f22/projects/proj5/#a-sample-dancing-bug",
    "relUrl": "/projects/proj5/#a-sample-dancing-bug"
  },"50": {
    "doc": "Project 5",
    "title": "Implementing the project",
    "content": "First, read through all of the assignment carefully. As you do so, think about what kinds of classes and objects you may need to create, and how your objects will interact. For this program you will be making many new classes: specifically ones representing specific kinds of dancers. Many of these classes will extend either DancingBug or each other. I will describe each class you need below. You can write these in any order, though they generally go from easiest to hardest. There are a few bugs which depend on other types as well. DanceTester . This class is already created for you, and is where you will write your testing code for each dancing bug, and the final main method. SpinBug . This bug is the most basic dancing bug. It should just turn right for each dance step. You should make a new SpinBug class that inherits from DancingBug and write a constructor for it. I suggest having the constructor take int row, int col to set the location of the bug. You can pick whatever color you want (the example SpinBug uses yellow). Override the step() method and have the bug turn right on each step. Stop and test: In DanceTester, write a testSpinBug() function that works similarly to testBoredBug. You should see your SpinBug dancing! . Your browser does not support the video tag. RoutineBug . This bug is more complicated. This bug follows a specified dance routine, performing one step of the routine at each step. This dance routine will be specified as an ArrayList of DanceSteps. This bug class should have a method which allows a user to set this list of steps. Then in its step() method, you should get the next step in the list and perform it with doStep(). When you get to the end of the list, go back to the beginning! . Begin by making a new RoutineBug class that inherits from DancingBug. You may choose the instance variables you want to use. You can pick whatever color you want (the example RoutineBug uses red). You will need to write the step() method, write a constructor, and a “setter” method to set the dance routine steps. Stop and test: In DanceTester, write a testRoutineBug() function. Here is an example dance routine you may use: . ArrayList&lt;DanceStep&gt; steps = new ArrayList&lt;DanceStep&gt;(); steps.add(DanceStep.STEP_RIGHT); steps.add(DanceStep.STEP_RIGHT); steps.add(DanceStep.STEP_RIGHT); steps.add(DanceStep.PAUSE); steps.add(DanceStep.STEP_LEFT); steps.add(DanceStep.STEP_LEFT); steps.add(DanceStep.STEP_LEFT); steps.add(DanceStep.PAUSE); steps.add(DanceStep.BACKWARD); steps.add(DanceStep.BACKWARD); steps.add(DanceStep.BACKWARD); steps.add(DanceStep.PAUSE); steps.add(DanceStep.FORWARD); steps.add(DanceStep.FORWARD); steps.add(DanceStep.FORWARD); steps.add(DanceStep.TURN_LEFT); . Your browser does not support the video tag. SquareBug . A SquareBug is a specialization of a RoutineBug: a SquareBug always does a specific routine (walks in a square). Begin by making a new SquareBug class that inherits from RoutineBug (not DancingBug!). You may choose the instance variables you want to use. A SquareBug constructor will take a int row, int col, int size to set its location, as well as the size of the square the bug will trace. Note that the constructor should use the size parameter to construct the appropriate dance routine automatically (a routine that will have the bug walk in a square of the size given). (Note: the size parameter should be interpreted as the number of steps the SquareBug takes when it walks forward. Therefore, the actual length of the side of the square the SquareBug traces will be one greater than the size parameter.) . If you have written this constructor appropriately, you will not need to override the step() method or any other methods. Stop and test: In DanceTester, write a testSquareBug() function that creates a SquareBug of size 4. Your browser does not support the video tag. LeaderBug . You’ll need to enable some bugs to lead other bugs (to give the other bugs directions about what dance steps to do). But you’ll want multiple different kinds of bugs to be able to lead. As such, we have provided you with a LeaderBug interface that other classes can implement. Remember that interfaces only have abstract methods — all the method bodies are left unspecified. And just like abstract classes, any class that implements an interface must define those methods. You’re specifying that all LeaderBugs are able to perform certain actions (methods)—the interface describes what those functions are. The interface for LeaderBug only has one method: . public abstract DanceStep getLastStep(); . This means that in order to be a LeaderBug, a class which implements this interface must define this getLastStep() method. The way the interface works is that any bug which wants to follow the directions of a LeaderBug must be able to ask the LeaderBug, “What was the last dance step you took?” The follower bug may query this by calling getLastStep() on the LeaderBug, and a DanceStep will be returned. Then the follower bug may choose to copy this dance step exactly, or take some other action. The next few bugs you will write will be follower bugs that are given access to a LeaderBug to follow. Note: This interface is already written for you, but you should open LeaderBug.java to look at it. Notice it looks a lot like a very basic abstract class, except it uses the word interface rather than class. There is nothing else to do for this step of the project. ImitationBug . The first follower bug you will write will be a bug that simply copies the exact dance steps of a LeaderBug. The graphical effect will be that the ImitationBug imitates whatever the LeaderBug is doing, so they will dance in sync. First, we will need to have a class that actually implements a LeaderBug so the ImitationBug can follow it. We will turn SpinBug into a LeaderBug. To do this, change the line in SpinBug from: . public class SpinBug extends DancingBug . to . public class SpinBug extends DancingBug implements LeaderBug . This tells Java that the SpinBug class will still have all the functionality of a DancingBug, but now will also have the functionality of a LeaderBug as well. So now you must add the public DanceStep getLastStep() method to this class. Remember, getLastStep() should simply return the last dance step this bug took. And since a SpinBug always turns right on every step, writing getLastStep() is literally one line of code. Second, create an ImitationBug class. The class definition line should be: . public class ImitationBug extends DancingBug . Add a private LeaderBug leaderBug instance variable to the class. This variable will hold the specific bug the ImitationBug is following. Add a constructor to the class that takes a row, a column, and a LeaderBug: . public ImitationBug(int row, int col, LeaderBug leaderBug) . The body of the constructor should set the appropriate instance variables from the parameters above. You may pick a color for the ImitationBug (in the demos, this is pink.) . Now, write the step() method for the ImitationBug. Since an ImitationBug simply copies whatever its LeaderBug does, this should be straightforward: ask the LeaderBug instance variable for whatever its last dance step was, and have the ImitationBug do that same step. Stop and test: In DanceTester, write a testImitationBug() function. Create a dance floor with a SpinBug and an ImitationBug that imitates the SpinBug. The effect should be two spinning bugs. Your browser does not support the video tag. A second ImitationBug . Change your RoutineBug class to also implement LeaderBug. This will be slightly more challenging that making the SpinBug into a LeaderBug, because the RoutineBug will be following an arbitrary dance routine. However, this should not be too much work. Stop and test: In DanceTester, write a testImitationBug2() function. Create a dance floor with a RoutineBug that performs the dance routine from earlier, and an ImitationBug that imitates the RoutineBug. The effect should be similar to the video below (though I added many more ImitationBugs). Your browser does not support the video tag. (Supposed to be a recreation of this:) . MirrorBug . The second follower bug you will write will be a bug that copies the exact dance steps of a LeaderBug, but does with right/left directions flipped. The graphical effect will be that the ImitationBug imitates whatever the LeaderBug is doing, but as if it is being done in a mirror. Create a MirrorBug class that operates just like ImitationBug, but imitates the dance with left and right swapped. In the demos, MirrorBugs are blue. Stop and test: In DanceTester, write a testMirrorBug() function. Create a dance floor with a SquareBug of size 4, and a MirrorBug that mirrors the SquareBug. The effect should be two SquareBugs tracing out identically-sized squares, but the paths will be mirrored. Your browser does not support the video tag. CongaBug . The final part of the project will be writing a bug class that will enable the bugs to dance a “conga line.” This dance is lead by a SquareBug that will simply walk in a square. Each bug behind the SquareBug is a CongaBug, whose job is to follow the bug in front of it (whether a SquareBug or another CongaBug). However, this particular style of following is not the same kind of following that the ImitationBug or the MirrorBug do; these earlier bugs always copy their LeaderBug in real time. A CongaBug, however, must observe what its LeaderBug does, but then delay that dance step by one unit of time (one call to step()). This will enable the bugs to turn corners one at a time, rather than simultaneously. Begin by adding a testCongaLine() function to DanceTester that simply creates a SquareBug that walks in a square of size 4. Note that a SquareBug is a (extends) RoutineBug, so a SquareBug is also a LeaderBug. Therefore, we can write a CongaBug class that is similar to ImitationBug and MirrorBug, but executes its LeaderBug’s steps with a one-step delay. Create this CongaBug class: similarly to the other “follower” bugs, this bug should have a constructor that takes a row and a column, along with a LeaderBug variable. The demos show CongaBugs in green. To write the step() function, you must think about how to delay the LeaderBug’s steps by one. Hint: try using an instance variable to save the most recent step of the LeaderBug. Then the step() function can execute the dance step in this variable, then call getLastStep() on the LeaderBug and update the result in the variable to be used on the subsequent call to step(). However, the very first call to step() will be problematic, because there is no delayed value for the LeaderBug’s last step yet. Instead, just have the CongaBug walk forward on the first call to step(). Stop and test: Modify testCongaLine() to add a CongaBug immediately behind the SquareBug, and have the CongaBug follow the SquareBug. At this point, both bugs should walk in a square, but the CongaBug should always be one step behind. (Note: because the bugs can’t turn and walk forward at the same time, whenever the SquareBug approaches a corner and turns, the CongaBug behind it will walk on top of the SquareBug for one time step. This is ok.) . Your browser does not support the video tag. We now want to add a second CongaBug to the conga line. So the conga line will consist of: . | SquareBug (front of the line) | CongaBug (following the SquareBug) | a second CongaBug (following the first CongaBug) | . To accomplish this, we must make CongaBug itself into a LeaderBug. This is not particularly difficult, but is slightly tricky because the CongaBug is now both a leader and a follower. So the definition line for CongaBug will now be: . public class CongaBug extends DancingBug implements LeaderBug . and you must write the getLastStep() method appropriately. Stop and test: Modify testCongaLine() to add a second CongaBug as explained above. At this point, you should have a three-bug conga line. Your browser does not support the video tag. main() function . Write a main method to let the user pick which test they want to see: . | SpinBug | RoutineBug (using the routine from above) | SquareBug | ImitationBug (imitating a RoutineBug) [earlier this said “imitating a SquareBug,” which is also fine, but that’s not a test case I asked you to write] | MirrorBug (mirroring a SquareBug) | CongaBug (3-bug conga line) | . ",
    "url": "/cs142-f22/projects/proj5/#implementing-the-project",
    "relUrl": "/projects/proj5/#implementing-the-project"
  },"51": {
    "doc": "Project 5",
    "title": "What to turn in",
    "content": "Through Canvas, turn in all your .java files. Additionally, upload a text file answering the following questions: . | What bugs and conceptual difficulties did you encounter? How did you overcome them? What did you learn? | Describe whatever help (if any) that you received. Don’t include readings, lectures, and exercises, but do include any help from other sources, such as websites or people (including classmates and friends) and attribute them by name. | Describe any serious problems you encountered while writing the program. | Did you do any of the challenges (see below)? If so, explain what you did. | List any other feedback you have. Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it. | . ",
    "url": "/cs142-f22/projects/proj5/#what-to-turn-in",
    "relUrl": "/projects/proj5/#what-to-turn-in"
  },"52": {
    "doc": "Project 5",
    "title": "Challenges",
    "content": ". | Add more types of bugs. | . ",
    "url": "/cs142-f22/projects/proj5/#challenges",
    "relUrl": "/projects/proj5/#challenges"
  },"53": {
    "doc": "Project 5",
    "title": "Project 5",
    "content": " ",
    "url": "/cs142-f22/projects/proj5/",
    "relUrl": "/projects/proj5/"
  },"54": {
    "doc": "Project 6",
    "title": "CS 142 Project 6: Freeform Game",
    "content": ". | Starter code | Concepts in this program . | The GameObject class | The Game class | . | Two sample games | Implementing your game . | Guidelines | . | Demonstrations | Hints | What to turn in | Alternative projects | . In this assignment, you will be designing a game of your choice using object-oriented programming techniques learned in class. There are particular requirements for obtaining certain grades on the project, so you can pick what grade you want to aim for. However, if you don’t want to create a game using this framework, you can talk to me and design a project of your choice. See the end of this page for details. You may also work with a partner for this project if you desire. ",
    "url": "/cs142-f22/projects/proj6/#cs-142-project-6-freeform-game",
    "relUrl": "/projects/proj6/#cs-142-project-6-freeform-game"
  },"55": {
    "doc": "Project 6",
    "title": "Starter code",
    "content": "Make sure you create the project in a place on your computer where you can find it! I suggest making a new subfolder in your CS 142 projects folder. You can download the starter code for this assignment by creating a new IntelliJ project from version control (VCS) and using the following URL: . https://github.com/pkirlin/cs142-f22-proj6 . ",
    "url": "/cs142-f22/projects/proj6/#starter-code",
    "relUrl": "/projects/proj6/#starter-code"
  },"56": {
    "doc": "Project 6",
    "title": "Concepts in this program",
    "content": "This project is almost entirely up to you in terms of both what you want the final game to look like and how it works, and also in terms of program design. I am providing you with a general framework that you should work within, but you can modify things as you see fit. The framework is designed around a canvas that holds a collection of GameObject objects. These GameObjects represent images that can move around the screen and interact with each other however you want them to. The GameObjects are stored inside the Game class (which you will either modify or make a copy of and modify the copy). The GameObject class . I recommend opening the GameObject.java file and following along as you read this description. A GameObject represents an image in the game that will be drawn somewhere on the canvas. GameObjects can represent any sort of object or entity in the game, be it yourself (your player or character), another character who might be a friend or an enemy or opponent, or some object in the environment that you might interact with in some way: food, a wall, something you can pick up and carry around, a vehicle you can get in and drive, a projectile of some sort, etc. The basic GameObject class can be used directly; but it is also intended to be subclassed. Each GameObject has the following instance variables: . | an (x, y) location, | an image filename used to display the object on the canvas, | a width and height (images will be automatically resized to fit in the width/height dimensions), and | a border color. The border might be used to show some additional information about an object, such as whether it is “on” or “active” or how much energy it has left. The border color could be used in a variety of different ways, or you can set it to null to hide the border. | . GameObjects have the following methods: . | public void draw(SimpleCanvas canvas): Each GameObject can draw itself on a canvas. The default draw() code simply draws the appropriate image with a border of the desired color. If you subclass GameObject, you may or may not want to override this method. | public boolean overlaps(GameObject other): GameObjects can detect when they collide or intersect with other GameObjects. You will write this method to detect when one object overlaps another one, which can be used in various ways in a game. | public boolean isInside(int x, int y): If you want to use the mouse in your game, you may want to implement this method that can be used to detect if an (x, y) point (presumably a mouse click) is inside the object. | public int getLeftX()/getRightX()/getTopY()/getBottomY()/getCenterX()/getCenterY(): These methods are used to calculate the boundaries of the object on the canvas. The (x, y) location instance variable stores the center of the image, so if we want to know where the four sides are, there are getter methods for those values. | Various setters and getters for the image filename, width, height, and border color. | . The Game class . I recommend opening the Game.java file and following along as you read this description. The Game class holds the main logic of your game. It is expected that you will make a class similar to this one, or just modify the Game.java file itself. I don’t necessarily recommend subclassing Game; it’s probably easier to copy and paste the code into a new file and just modify the copy. That way you still have the basic Game.java skeleton to refer back to. I will describe the general workings of this class, but you can modify it as you want/need to. | Instance variables: Your class can have whatever instance variables you want. Most likely you will need some GameObjects or probably variables of a subclass of GameObject. You might need ArrayLists of GameObjects or their subclasses, depending on the game you design. | There is also an instance variable for the canvas you will draw the game on. | . Methods: . | public void draw(): This method is responsible for drawing the current “state” of the game on the canvas. I recommend you do not do much drawing outside of this method, otherwise it will become challenging to keep track of what should be drawn when. Exceptions might be small things like status messages on the canvas. You will need to write most of the code for this method. | private boolean isGameOver(): This method returns true when the game is over. It is not necessary to use this method if you don’t want to, but if you do, you will need to write its code. | public void runGame(): This method starts the game running. You will need to fill in lots of the code here, but there are comments and a general guide included in the code I’ve given you already. However, you should feel free to deviate from this guide if you want. | private void handleKeyboard(): This method is called by runGame() to handle when the user presses keys on the keyboard. This could be used to move something in the game around (like a character or other GameObject), or switch between different “modes” or “options” in the game (spells to cast, attack or defense strategies, etc). If you want to do anything with the keyboard, I suggest filling in this method. There is code already written for you that demonstrates using the arrow keys, but you can detect any key on the keyboard with a similar strategy. | private void handleMouse(): This method is called by runGame() to handle when the user clicks the mouse. In truth, it detects when the mouse button is down, so if you hold the mouse down it it might register in your program more than once. The mouse might be used to select objects in the game, move them around, target objects, etc. If you want to do anything with the mouse, I suggest filling in this method. There is code already written for you that demonstrates how to get the (x, y) location of the mouse click. | . ",
    "url": "/cs142-f22/projects/proj6/#concepts-in-this-program",
    "relUrl": "/projects/proj6/#concepts-in-this-program"
  },"57": {
    "doc": "Project 6",
    "title": "Two sample games",
    "content": ". | Open and run the RunDefaultGame class. This class serves as the “driver” code for the basic Game class, which really doesn’t do anything. When you run the code, it will open a canvas (that will be blank) and you can click the mouse and press the arrow keys, and messages will be printed showing information about what you clicked and pressed. This will serve as a good demonstration of how the Game class works and how you might go about making your own game. | Now open and run the RunAlarmGame class. This class is a (slightly) more sophisticated game. The idea is that you (the robot) need to turn off the alarm clock in a certain amount of time. The robot turns off the alarm clock by touching it (so the two pictures intersect). The problem is that some of the code is not written, namely, the code to detect when the the robot and the clock are touching. Furthermore, it is possible to move the robot off the screen, which we don’t want to allow. The game logic for this game is in the AlarmGame class, which you should look at, along with the AlarmClock class. AlarmGame illustrates how to use GameObjects, how to use the keyboard to move an object around the canvas, and how to write code for draw(), runGame(), and handleKeyboard(). You should also look at the code for the AlarmClock class, a subclass of GameObject. This is a good example of how to make a subclass of GameObject with its own logic. Here, we added an update() method to the class that is called once through the main game loop in runGame(), along with an instance variable and getter method to keep track of the “amount of time left” on the clock before it runs out. | . ",
    "url": "/cs142-f22/projects/proj6/#two-sample-games",
    "relUrl": "/projects/proj6/#two-sample-games"
  },"58": {
    "doc": "Project 6",
    "title": "Implementing your game",
    "content": "First, read through all of the assignment carefully. Because this is a freeform project, you can design whatever classes you want. You will most likely need to make one or more subclasses of GameObject. You can add others classes as you see fit. Guidelines . Below, I specify exactly what you need to do get a “baseline” grade of A, B, or C. Completing the requirements for that particular baseline grade will earn you that grade, provided that you do all the other things required for programs, such as proper documentation/comments, good use of object-oriented design, etc. Excellent work will give you up to 4 additional points, but will not move you to the next letter grade boundary. In other words, if you complete the guidelines for a “B” project, you will earn a baseline score of 85 points, plus up to 4 more for good object oriented design and programming choices, but you cannot earn a higher grade than 89. | For a baseline grade of “C” (a 75), you must: . | Implement the alarm clock game so that . | The game ends either when the robot touches the alarm clock (a win), or when the time runs out (goes negative, which is a loss). | The robot must not be allowed to leave the boundary of the canvas. As it stands, the keyboard can take the robot off the board, and you should prevent this from happening. | . | Note that to implement detecting when the robot touches the clock, you will need to write the code in GameObject for the overlaps() method. | . | For a baseline grade of “B” (an 85), you must implement a game with the following features: . | There will be a GameObject representing the player. Similarly to the “C” project, the player should not be allowed to leave the boundaries of the screen. | There will be a collection of GameObjects representing “good” objects and “bad” objects, that will scroll across the screen in one direction. You should have at least one subclass of GameObject for each type of object (“good” versus “bad”). You may wish to make more subclasses as well. | The player can use the keyboard to move around the canvas. When a player touches an object, it disappears. “Good” objects earn points, while “bad” objects deduct points. You should implement the overlap() method in GameObject for this. | Objects that scroll off the screen without being touched should be replaced in some way. | You get to choose the game’s theme/story, by choosing the images, distribution of objects, game speed, scoring function, and game-over condition. You can also vary things like how the objects move, their sizes, and how many points each one earns. And, of course, you can do more if you like, as long as your game still fits the description given above. (Be sure to choose a theme for your game that is appropriate for a general audience!) | . | For a baseline grade of “A” (a 95), you must implement a game with some of following features: . | In general, you should do everything a “B” game does, but you can relax some of the rules if they don’t fit your game idea. In other words, it should be some game where there are objects that move around and the player touches them to advance the game in some way. Here are things you can modify: | The main player character might have more capabilities than in a “B” project. For example, maybe they have spells they can cast, or weapons they can use, or objects they can “throw,” or they can change their size, or they might carry an inventory around, or they can change the way they move around the world, etc. Maybe there are multiple players you can control. Maybe the player has other attributes they keep track of besides the number of points, such as their armor, or life left, or what they are wearing. These might affect when the game ends or other gameplay features. | The other objects might move in different ways (as opposed to just right to left). Maybe they bounce around (like in the Fish lab) or maybe they will seek out the player and move towards them, or maybe they avoid the player and move away from them. Maybe they have other capabilities like in the paragraph above (spells, weapons, an inventory, changing sizes, …). Maybe they work together as a team in some way. | Your game might use the mouse in some way, to target other players or objects. | You do not need to do all of these things for an “A”. However, the more you do, the higher your grade will be. | . | . Baseline grades may be adjusted up or down for for excellent or poor use of object-oriented programming techniques. You may need to write another class like RunDefaultGame or RunAlarmGame to get your game started. ",
    "url": "/cs142-f22/projects/proj6/#implementing-your-game",
    "relUrl": "/projects/proj6/#implementing-your-game"
  },"59": {
    "doc": "Project 6",
    "title": "Demonstrations",
    "content": "The alarm clock game, when won, should work more or less like this: . Your browser does not support the video tag. The alarm clock game, when lost, should work more or less like this: . Your browser does not support the video tag. Here’s a very basic “B” game, probably the minimal “B” game you could write. Your game, to get an 85, should have more of a theme other than check marks and X’s. Your browser does not support the video tag. ",
    "url": "/cs142-f22/projects/proj6/#demonstrations",
    "relUrl": "/projects/proj6/#demonstrations"
  },"60": {
    "doc": "Project 6",
    "title": "Hints",
    "content": ". | For the “B” game: . | Try keeping an ArrayList of the GameObjects that are scrolling by. You can move them a few pixels to the left each time through the game loop in runGame(). You can also loop over the ArrayList to check if any of them overlap with the player object, at which point they should disappear (remove them from the ArrayList or move them back to the right edge of the screen). | When you have images that scroll off the screen, you should remove them from the game if they will never appear again. For instance, when images scroll off the left side, you can detect when they are no longer visible, and either remove them from the ArrayList entirely, or move them back to the right side of the screen so they will scroll by again. What you don’t want to do is create more and more images forever, because this will eventually slow the game down. Basically you want the ArrayList to always have a fixed number of objects in it. | . | You can find plenty of images online to use in your game. You can also use emoji images (these work well because they are small sizes) at Emojipedia. Google Image Search also works well using the term “icon,” like “snowman icon” or “wizard icon.” You can also use Google Image search and under “Tools,” pick “Clip Art.” But truly any image will work fine. | . ",
    "url": "/cs142-f22/projects/proj6/#hints",
    "relUrl": "/projects/proj6/#hints"
  },"61": {
    "doc": "Project 6",
    "title": "What to turn in",
    "content": "Note that you need to turn in all your files for this project! . Through Canvas, turn in all your .java files and all your image files. If it’s easier, you may upload a zip file with all the files. Additionally, upload a text file answering the following questions: (note that there is an extra question!) . | Which baseline project (A, B, or C) did you implement? Describe what specific features you implemented that I should look for. | What bugs and conceptual difficulties did you encounter? How did you overcome them? What did you learn? | Describe whatever help (if any) that you received. Don’t include readings, lectures, and exercises, but do include any help from other sources, such as websites or people (including classmates and friends) and attribute them by name. | Describe any serious problems you encountered while writing the program. | Did you do any of the challenges (see below)? If so, explain what you did. | List any other feedback you have. Feel free to provide any feedback on how much you learned from doing the assignment, and whether you enjoyed doing it. | . ",
    "url": "/cs142-f22/projects/proj6/#what-to-turn-in",
    "relUrl": "/projects/proj6/#what-to-turn-in"
  },"62": {
    "doc": "Project 6",
    "title": "Alternative projects",
    "content": "If you don’t like the idea of creating a game, talk to me and suggest an alternative project, and we’ll work out what you need to do to have it substitute for this project. ",
    "url": "/cs142-f22/projects/proj6/#alternative-projects",
    "relUrl": "/projects/proj6/#alternative-projects"
  },"63": {
    "doc": "Project 6",
    "title": "Project 6",
    "content": " ",
    "url": "/cs142-f22/projects/proj6/",
    "relUrl": "/projects/proj6/"
  },"64": {
    "doc": "Project 1",
    "title": "CS 142 Project 1",
    "content": "You will write a program that simulates the two-player game Nim. Nim is a simple game that where two players are presented with a number of piles of sticks. The two players alternate removing sticks from one pile at a time according to certain rules. The goal of the game is sometimes to remove the last stick, or avoid removing the last stick. Here are the rules for our version of the game. The game begins with three piles, labeled A, B, and C. Pile A starts with 5 sticks, B with 4, and C with 3. Player 1 moves first, and is allowed to remove any number of sticks (&gt; 0) from a single pile. Player 2 then moves, and is allowed to make a similar choice: they choose a pile, and remove any positive number of sticks from that pile. The two players alternate turns until one player is forced to take the last stick (usually because it is the only one left). That player loses the game, and the other player wins. ",
    "url": "/cs142-f22/projects/proj1/#cs-142-project-1",
    "relUrl": "/projects/proj1/#cs-142-project-1"
  },"65": {
    "doc": "Project 1",
    "title": "What you need to do",
    "content": ". | Create a new IntelliJ project. Inside, create a new Java class called Nim. Write a main function inside this class that allows two players to play a game of Nim, starting from the 5/4/3 situation described above. | While your program is running, it should clearly show whose turn it is, the state of the piles of sticks, and prompt each player for a pile (a String) and a number of sticks to remove from that pile (an integer). | Your program should not allow a user to enter an improper pile (only A, B, and C should be allowed), nor an invalid number of sticks to remove from that pile (i.e., negative numbers should not be allowed, nor a number of sticks greater than the number left in that pile). | At the end of the game (whenever the last stick is removed), announce the winner. | . ",
    "url": "/cs142-f22/projects/proj1/#what-you-need-to-do",
    "relUrl": "/projects/proj1/#what-you-need-to-do"
  },"66": {
    "doc": "Project 1",
    "title": "Testing your program",
    "content": ". | You should test your program thoroughly to make sure it works. | Your program should gracefully handle situations where either the pile is mistyped (ask for it again), or the number of sticks to removed is wrong (ask for it again). | You may assume the players will never enter a non-integer for the number of sticks to remove. | . ",
    "url": "/cs142-f22/projects/proj1/#testing-your-program",
    "relUrl": "/projects/proj1/#testing-your-program"
  },"67": {
    "doc": "Project 1",
    "title": "Sample interactions",
    "content": "Run 1: . It's player 1's turn. Here is the board: A B C 5 4 3 Enter the pile: A How many sticks would you like to remove from pile A? 3 It's player 2's turn. Here is the board: A B C 2 4 3 Enter the pile: B How many sticks would you like to remove from pile B? 3 It's player 1's turn. Here is the board: A B C 2 1 3 Enter the pile: C How many sticks would you like to remove from pile C? 2 It's player 2's turn. Here is the board: A B C 2 1 1 Enter the pile: C How many sticks would you like to remove from pile C? 1 It's player 1's turn. Here is the board: A B C 2 1 0 Enter the pile: A How many sticks would you like to remove from pile A? 2 It's player 2's turn. Here is the board: A B C 0 1 0 Enter the pile: B How many sticks would you like to remove from pile B? 1 The winner is player 1! . Run 2: . It's player 1's turn. Here is the board: A B C 5 4 3 Enter the pile: A How many sticks would you like to remove from pile A? 5 It's player 2's turn. Here is the board: A B C 0 4 3 Enter the pile: C How many sticks would you like to remove from pile C? 6 Invalid number of sticks; please re-enter number: -2 Invalid number of sticks; please re-enter number: 0 Invalid number of sticks; please re-enter number: 2 It's player 1's turn. Here is the board: A B C 0 4 1 Enter the pile: D Invalid pile; please re-enter the pile: Z Invalid pile; please re-enter the pile: B How many sticks would you like to remove from pile B? 4 It's player 2's turn. Here is the board: A B C 0 0 1 Enter the pile: C How many sticks would you like to remove from pile C? 1 The winner is player 1! . ",
    "url": "/cs142-f22/projects/proj1/#sample-interactions",
    "relUrl": "/projects/proj1/#sample-interactions"
  },"68": {
    "doc": "Project 1",
    "title": "What to turn in",
    "content": "Through Canvas, turn in your Nim.java file. Additionally, upload a text file answering the following questions: . | What bugs and conceptual difficulties did you encounter? How did you overcome them? What did you learn? | Describe whatever help (if any) that you received. Don’t include readings, lectures, and exercises, but do include any help from other sources, such as websites or people (including classmates and friends) and attribute them by name. | Describe any serious problems you encountered while writing the program. | Did you do any of the challenges (see below)? If so, explain what you did. | List any other feedback you have. Feel free to provide any feedbackon how much you learned from doing the assignment, and whether you enjoyed doing it. | . ",
    "url": "/cs142-f22/projects/proj1/#what-to-turn-in",
    "relUrl": "/projects/proj1/#what-to-turn-in"
  },"69": {
    "doc": "Project 1",
    "title": "Guidelines",
    "content": ". | You should use good programming style when writing your program, except that you don’t need to use functions in Java because we haven’t fully learned them yet. You may use them if you so desire. All other style guidelines, including proper indentation and comments, should be followed. | In particular, be sure to include a block comment at the top of your program with your name and the statement ``I have neither given nor received unauthorized aid on this program.’’ . | . ",
    "url": "/cs142-f22/projects/proj1/#guidelines",
    "relUrl": "/projects/proj1/#guidelines"
  },"70": {
    "doc": "Project 1",
    "title": "Hints and tips",
    "content": ". | You may choose to represent the piles either as three separate ints or as an int array (int[]). | To allow the user to enter the letter for a pile, I recommend using the next() function from the Scanner class. We normally use nextInt(), nextDouble(), etc, but the one for Strings is called simply next(). Note that nextLine() is also a valid function, but can cause problems when reading both numbers and Strings int the same program, so definitely use next() here. | Comparing Strings in Java is a bit tricky as well. If you have two Strings, you shouldn’t compare them with == or !=: String str = scanner.next(); if (str == \"A\") { // don't do this! statements... } . The code above is legal, however the comparison will sometimes work correctly and sometimes not (it will be clear later). The correct way to compare Strings in Java for equality or inequality is: . // compare for equality if (str.equals(\"A\")) { statements... } // compare for inequality: if (!str.equals(\"A\")) { // the exclamation point means \"not\" statements... } . | . ",
    "url": "/cs142-f22/projects/proj1/#hints-and-tips",
    "relUrl": "/projects/proj1/#hints-and-tips"
  },"71": {
    "doc": "Project 1",
    "title": "Challenge Problems",
    "content": "From time to time, I will offer “challenge problems” on assignments. These problems are designed to have little (but some) impact on your grade whether you do them or not. You should think of these problems as opportunities to work on something interesting and optional, rather than a way to raise your grade through “extra credit.” . Policy on challenge problems: . | Challenge problems will typically allow you to get 2-5% of additional credit on an assignment, yet they will typically be much more difficult than this credit amount suggests. | You should not attempt a challenge problem until you have finished the rest of an assignment. | The tutors will not provide help on challenge problems. The instructor will provide minimal assistance only, as these problems are optional and are designed to encourage independent thought. | Challenge problems may be less carefully specified and less carefully calibrated for how difficult or time-consuming they are. | If you solve a challenge problem, include a comment at the top of your program detailing what you did. | . Challenge problems for this assignment (upload in a separate file called NimChallenge.java; also turn in your regular Nim.java file without the challenges): . | Let the players enter the starting number of sticks in each pile before the game starts. | Add a computer player that plays randomly and let the user choose whether or not they want to play the computer or another (human) player. | Have the computer player use some sort of intelligent strategy (but not cheat). | Let the two players repeatedly play against each other. Report some statistics about the series of games at the end (how many wins for each player, most popular opening moves, etc). | . ",
    "url": "/cs142-f22/projects/proj1/#challenge-problems",
    "relUrl": "/projects/proj1/#challenge-problems"
  },"72": {
    "doc": "Project 1",
    "title": "Project 1",
    "content": " ",
    "url": "/cs142-f22/projects/proj1/",
    "relUrl": "/projects/proj1/"
  },"73": {
    "doc": "Projects",
    "title": "Projects",
    "content": " ",
    "url": "/cs142-f22/projects/",
    "relUrl": "/projects/"
  },"74": {
    "doc": "Homework 2",
    "title": "CS142: Homework 2",
    "content": "Homework problems are intended to give you more practice with shorter programs than the larger “projects” do. Typically these problems will also give you an idea of what you might see on tests. You also get immediate feedback. This is another CodeCheck homework. If you’ve forgotten how this works, look at homework 1. Here’s the link for the assignment. When you’re all done, paste your CodeCheck ID into the Canvas assignment and submit it. ",
    "url": "/cs142-f22/homework/hw2/#cs142-homework-2",
    "relUrl": "/homework/hw2/#cs142-homework-2"
  },"75": {
    "doc": "Homework 2",
    "title": "Homework 2",
    "content": " ",
    "url": "/cs142-f22/homework/hw2/",
    "relUrl": "/homework/hw2/"
  },"76": {
    "doc": "Homework 3",
    "title": "CS142: Homework 3",
    "content": "Homework problems are intended to give you more practice with shorter programs than the larger “projects” do. Typically these problems will also give you an idea of what you might see on tests. You also get immediate feedback. This is another CodeCheck homework. If you’ve forgotten how this works, look at homework 1. Important: If CodeCheck has been not saving your work, try making sure to click the “CodeCheck” button towards the button whenever you walk away for a bit, even if you’re not ready to test your code. If you’re still having problems, you can also paste in the code and/or screenshots of all the test cases passing when you submit to Canvas. Here’s the link for the assignment. When you’re all done, paste your CodeCheck ID into the Canvas assignment and submit it. ",
    "url": "/cs142-f22/homework/hw3/#cs142-homework-3",
    "relUrl": "/homework/hw3/#cs142-homework-3"
  },"77": {
    "doc": "Homework 3",
    "title": "Homework 3",
    "content": " ",
    "url": "/cs142-f22/homework/hw3/",
    "relUrl": "/homework/hw3/"
  },"78": {
    "doc": "Homework 1",
    "title": "CS142: Homework 1",
    "content": "Homework problems are intended to give you more practice with shorter programs than the larger “projects” do. Typically these problems will also give you an idea of what you might see on tests. You also get immediate feedback. For this homework, you will write some small programs using a website called CodeCheck. This website lets you program your solutions in the website itself, but I recommend making an IntelliJ project and doing your work there, because often it’s easier and faster to write and test in IntelliJ than directly in CodeCheck. ",
    "url": "/cs142-f22/homework/hw1/#cs142-homework-1",
    "relUrl": "/homework/hw1/#cs142-homework-1"
  },"79": {
    "doc": "Homework 1",
    "title": "How CodeCheck works",
    "content": ". | You will be given a URL to a CodeCheck assignment which consists of a series of short programming problems. | When you first load the assignment it will generate a “CodeCheck ID” for you. This is a unique identifier that you will submit to Canvas when you’re done with the assignment; it lets me match up your assignment with your name. | If you use the same computer all the time, your CodeCheck ID is automatically saved in your browser and when you come back to the assignment, all your work will be restored from where you left off. However, CodeCheck also generates a “private URL” that you can save as well that will enable you to retrieve your work from a different computer. Note that if you clear your browser’s cache or cookies, the CodeCheck ID is forgotten and you’ll need the private URL to get back to your work. | In other words, you should bookmark the private URL (or copy and paste it somewhere) since that will always enable you to get your work back. | Click on the numbered buttons below the private URL to move between problems. Each problem requires writing a piece of code. When you think you’ve solved a problem, you can click the “CodeCheck” button to run the code, and the website will tell you whether your code works or not. You can do this as many times as you want; there is no penalty for doing it often, and only the last attempt is recorded. | I recommend copying each problem into IntelliJ to work on it. Note that the name of a class in Java must be saved in a file with the same name. So for instance, for the first problem, note that it’s in a class called ForLoop, so you should make a class in Java also called ForLoop, then copy and paste the code into that file. | . ",
    "url": "/cs142-f22/homework/hw1/#how-codecheck-works",
    "relUrl": "/homework/hw1/#how-codecheck-works"
  },"80": {
    "doc": "Homework 1",
    "title": "OK, I get it, let’s get going!",
    "content": "Here’s the URL for the assignment: https://codecheck.io/assignment/21090220439s46v43pvnhbgoseujats2tze. ",
    "url": "/cs142-f22/homework/hw1/#ok-i-get-it-lets-get-going",
    "relUrl": "/homework/hw1/#ok-i-get-it-lets-get-going"
  },"81": {
    "doc": "Homework 1",
    "title": "Turning in the homework",
    "content": "You can turn in the homework in one of two ways. The easiest way is to paste your CodeCheck ID into the Canvas assignment and submit it. The second way is you can take screenshots of your code and submit those to canvas instead. In the past, a handful of students have said they’ve experienced problems with CodeCheck not saving their progress, so this might work better for you. ",
    "url": "/cs142-f22/homework/hw1/#turning-in-the-homework",
    "relUrl": "/homework/hw1/#turning-in-the-homework"
  },"82": {
    "doc": "Homework 1",
    "title": "Homework 1",
    "content": " ",
    "url": "/cs142-f22/homework/hw1/",
    "relUrl": "/homework/hw1/"
  },"83": {
    "doc": "Homework",
    "title": "Homework",
    "content": " ",
    "url": "/cs142-f22/homework/",
    "relUrl": "/homework/"
  },"84": {
    "doc": "Home",
    "title": "Computer Science II: Object-Oriented Programming",
    "content": "Fall 2022 . ",
    "url": "/cs142-f22/#computer-science-ii-object-oriented-programming",
    "relUrl": "/#computer-science-ii-object-oriented-programming"
  },"85": {
    "doc": "Home",
    "title": "Administrivia",
    "content": ". | Instructor: Phillip Kirlin | Office hours: Mon 12-1, Tue 9-10:30, Wed 3-4, Thu 10-11:30. Also available by appointment and over Slack. | Canvas page: Use for grades, online assignment submissions, and assignment solutions. | Syllabus and additional policies. | Tutoring hours: Sunday through Thursday evenings, 5-11pm, Briggs 001 | Final exam times: . | Friday, December 9, 1-3:30, FJ-B | Monday, Dec 12, 8:30-11:00, Spence Wilson Room (in Briggs) | . | . ",
    "url": "/cs142-f22/#administrivia",
    "relUrl": "/#administrivia"
  },"86": {
    "doc": "Home",
    "title": "Resources",
    "content": ". | Textbooks and tutorials: Introduction to Java by Liang (textbook), Introduction to Programming in Java by Sedgewick and Wayne (textbook), official Java tutorials, Introduction to Programming Using Java (free online textbook) | Java in the browser: Repl.it, CodeHS | Official Java documentation | . ",
    "url": "/cs142-f22/#resources",
    "relUrl": "/#resources"
  },"87": {
    "doc": "Home",
    "title": "Calendar",
    "content": " ",
    "url": "/cs142-f22/#calendar",
    "relUrl": "/#calendar"
  },"88": {
    "doc": "Home",
    "title": "",
    "content": "Wed, Aug 24 Introduction, go over syllabus, introduce Java. Printing, variables, user input, math, if/else, loops. Handout: Java basics, Programs for today. Slides Code Reading Liang chapter 2 (basics), chapter 3 (if statements). Fri, Aug 26 Continue with Java. Random number generation, while loops. while loop handout. Code Reading Liang chapter 5 (loops). Mon, Aug 29 Continue with Java. For loops and functions. for loop handout, functions handout, functions practice. Reading Liang chapter 5 (loops) and chapter 6 (functions). Wed, Aug 31 Lab Lab 1 Reading Liang 7.0-7.8 (arrays). Project Project 1 (due Thu, Sep 8) Fri, Sep 2 Practice with functions. Handout with practice problems. Mon, Sep 5 Labor Day Wed, Sep 7 Lab Lab 2 Homework Homework 1 (due Thu, Sep 15) Fri, Sep 9 Object-Oriented Programming I Introduction to OOP concepts and terminology. OOP definitions 10am code 11am code Reading Sedgewick &amp; Wayne 3.1, pp. 329-325 (OO concepts). Mon, Sep 12 Object-Oriented Programming II Using classes and objects designed by others. SimpleCanvas and Color APIs 10am code 11am code Wed, Sep 14 Lab Lab 3 Reading Liang chapter 8 (multidimensional arrays). Fri, Sep 16 Object-Oriented Programming III OOP “gotchas” and learning about references. Gotchas handout 10am code 11am code Mon, Sep 19 Creating Classes I Learning how to design simple classes. Class design handout Slides 10am code 11am code Reading Liang 9.1-9.3, 9.5 (creating classes). Project Project 2 (due Thu, Sep 29) Wed, Sep 21 Lab Lab 4 Fri, Sep 23 Creating Classes II public and private. Reading Liang 9.8 (public/private). Mon, Sep 26 Creating Classes III Constructors. Slides Reading Liang 9.4 (constructors). Homework Homework 2 (due Mon, Oct 3) Wed, Sep 28 Lab Lab 5 Fri, Sep 30 OO Design Practices Designing a Fraction class. 10am code 11am code Mon, Oct 3 Review for midterm 10am code 11am code Wed, Oct 5 Midterm I Fri, Oct 7 OO Design Practices More practice with the Fraction class. 10am code 11am code Mon, Oct 10 ArrayLists, Strings, and File Reading String handout, ArrayList handout, Practice problems 10am code 11am code Wed, Oct 12 Lab Lab 6 Project Project 3 (due Wed, Oct 26) Fri, Oct 14 ArrayLists, Strings, and File Reading Continue practice from Wednesday. 10am code 11am code Reading Liang 11.11 (ArrayLists), 4.4 and 10.10 (strings). Mon, Oct 17 Fall break Wed, Oct 19 Lab Lab 7 Fri, Oct 21 Recursion I Recursion handout Slides 10am code 11am code Reading Liang 18.1-18.2 (recursion intro). Mon, Oct 24 Recursion II 10pm code 11am code Reading Liang 18.3 (recursion continued). Pay special attention to Figures 18.2 and 18.3 on page 722; these are important to understand. Wed, Oct 26 Lab Lab 8 Fri, Oct 28 Recursion III Recursive functions with arrays Recursion with arrays handout Slides 10am code 11am code Mon, Oct 31 Recursion IV Binary search Binary search handout Slides 10am code 11am code Project Project 4 (due Mon, Nov 14) Wed, Nov 2 Lab Lab 9 Homework Homework 3 (due Thu, Nov 10) Fri, Nov 4 Inheritance I Inheritance handout Slides 10am code 11am code Reading Liang 11.1-11.2 (inheritance). Mon, Nov 7 (Class canceled) Wed, Nov 9 Inheritance II Lab Lab 10 Fri, Nov 11 Finish lab 10 Mon, Nov 14 Polymorphism I 10am code 11am code Reading Liang 11.7-11.9 (polymorphism). Wed, Nov 16 Polymorphism II (abstract classes) and Review 10am code 11am code Project Project 5 (due Thu, Dec 1) Fri, Nov 18 Midterm II Mon, Nov 21 Band in a Box (abstract classes) 10am code 11am code Wed, Nov 23 No class, Thanksgiving break Fri, Nov 25 No class, Thanksgiving break Mon, Nov 28 Interfaces 10am code 11am code Reading Liang 11.5-11.6 (interfaces). Wed, Nov 30 Lab Lab 11 Fri, Dec 2 Big Oh How computer scientists measure how fast algorithms run. Project Project 6 (due Wed, Dec 14) Mon, Dec 5 Big Oh, continued Big Oh handout Wed, Dec 7 TBA ",
    "url": "/cs142-f22/",
    "relUrl": "/"
  },"89": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/cs142-f22/",
    "relUrl": "/"
  },"90": {
    "doc": "Lab 2",
    "title": "CS 142 Lab 2",
    "content": " ",
    "url": "/cs142-f22/labs/lab2/#cs-142-lab-2",
    "relUrl": "/labs/lab2/#cs-142-lab-2"
  },"91": {
    "doc": "Lab 2",
    "title": "Wheel of Fortune",
    "content": ". | Start IntelliJ. From the screen that appears, choose “Get from VCS.” This is new; we haven’t used this option before. We will make a new project to store all of our labs and code that I want to distribute to the whole class. | On the next screen, copy and paste in the following URL in the box that says “URL”: . https://github.com/pkirlin/cs142-f22-inclass . In the “Directory” box, double-check that the folder listed is the right place for new projects to be stored (a subfolder of your main cs142 projects). If something is off, you can click the folder icon at the far right of the text area and make a new folder for this class work. | In the left-hand panel, expand the src folder to see today’s lab (in the lab2 folder). Double-click on WheelOfFortune (not the md file yet.) If you get a message at the top that says “Project JDK is not defined,” then click on “Setup SDK” and choose the JDK you downloaded earlier. | In the left-hand panel, double-click on WheelOfFortune.md. Follow the instructions in this file. This is where you will answer the questions for the lab. | . ",
    "url": "/cs142-f22/labs/lab2/#wheel-of-fortune",
    "relUrl": "/labs/lab2/#wheel-of-fortune"
  },"92": {
    "doc": "Lab 2",
    "title": "Submitting the lab",
    "content": "At the end of the lab session, upload the two files to canvas. ",
    "url": "/cs142-f22/labs/lab2/#submitting-the-lab",
    "relUrl": "/labs/lab2/#submitting-the-lab"
  },"93": {
    "doc": "Lab 2",
    "title": "Lab 2",
    "content": " ",
    "url": "/cs142-f22/labs/lab2/",
    "relUrl": "/labs/lab2/"
  },"94": {
    "doc": "Lab 1",
    "title": "CS 142 Lab 1",
    "content": " ",
    "url": "/cs142-f22/labs/lab1/#cs-142-lab-1",
    "relUrl": "/labs/lab1/#cs-142-lab-1"
  },"95": {
    "doc": "Lab 1",
    "title": "Part A: Leroy and the Cookies",
    "content": "In Part A, you will play a game already written for you in Java. Through playing the game and investigating the code, you will practice with Java variables, if statements, and loops. Getting started . | Start IntelliJ. From the screen that appears, choose “New Project.” . | On the “New Project” screen, pick a name for your project, for example “lab1.” It’s easier if it doesn’t have spaces in it. Choose a location for your project. I suggest making a folder dedicated just to CS142 projects, and then storing your project in this folder. If the “JDK” section of this screen says “No JDK”, click the dropdown box and choose “Download JDK.” Pick version 18, and the Oracle vendor. Click “Download.” . Unselect the checkbox for “Add sample code.” . Once the JDK is downloaded, you can click “Create” to create your project. | Download the following three files to your computer (make sure you know where they’re being downloaded to): . (This may involve right-clicking and choosing “Save As” or “Save Link As”) depending on your operating system and browser. | LeroyAndTheCookies.java | LeroyAndTheCookies.md | OneIsZero.java | . | In the left-hand panel, find the src folder. This is where your Java files should reside. Find the three files above on your computer and drag-and-drop them into the src folder in IntelliJ. | In the left-hand panel, double-click on LeroyAndTheCookies.java. Click the “run” button (green triangle) in the upper-right area of IntelliJ to run the Java code. If it doesn’t run, ask for help. Now you’re ready to start the lab! . | In the left-hand panel, double-click on LeroyAndTheCookies.md. Follow the instructions in this file. This is where you will answer the questions for the lab. | . ",
    "url": "/cs142-f22/labs/lab1/#part-a-leroy-and-the-cookies",
    "relUrl": "/labs/lab1/#part-a-leroy-and-the-cookies"
  },"96": {
    "doc": "Lab 1",
    "title": "Part B: One Is Zero",
    "content": "After you finish Part A, try to write the second program from our previous class, “One is Zero.” Directions are in the OneIsZero.java file (or see the class webpage or your handout.) . ",
    "url": "/cs142-f22/labs/lab1/#part-b-one-is-zero",
    "relUrl": "/labs/lab1/#part-b-one-is-zero"
  },"97": {
    "doc": "Lab 1",
    "title": "Submitting the lab",
    "content": "At the end of the lab session, upload the two LeroyAndTheCookies files to canvas. Also include OneIsZero.java if you made any progress on that. ",
    "url": "/cs142-f22/labs/lab1/#submitting-the-lab",
    "relUrl": "/labs/lab1/#submitting-the-lab"
  },"98": {
    "doc": "Lab 1",
    "title": "Lab 1",
    "content": " ",
    "url": "/cs142-f22/labs/lab1/",
    "relUrl": "/labs/lab1/"
  },"99": {
    "doc": "First recursive formulation",
    "title": "First recursive formulation",
    "content": ". | Is the patronus at the same location as the cup? If so, return success. | Check if the patronus can move one step north. If so, recursively solve the maze from one step north. If this recursive call succeeds, then we succeed. | Check if the patronus can move one step south. If so, recursively solve the maze from one step south. If this recursive call succeeds, then we succeed. | Repeat for east and west. (So always north first, then south, then east, then west.) | If none of the (up to four) recursive calls succeeded, then fail. | . Let’s run through this idea with maze0.txt, repeated here, with labels on the rows and columns: . 0123 0#### 1# ## 2# C# 3#H## 4#### . The patronus begins at (3, 1) (remember this is row=3, col=1), so we begin by calling canSolve(3, 1). The cup is not at (3, 1), so we try solving one from step north (make a recursive call at (2, 1). The cup is not at (2, 1), so again we recursively solve from one step north, so we make a recursive call at (1, 1). Again, the cup isn’t at (1, 1), so we try going north, but that isn’t possible (because the hedge blocks us). We try south, but that’s where we just came from, so that isn’t a good idea (your code will drop a breadcrumb to prevent this). We try east and west, but those are both blocked. So it turns out (1, 1) is a dead end. So far this is a diagram of our recursive calls: . canSolve(3, 1) | +--&gt; canSolve(2, 1) | +--&gt; canSolve(1, 1) | +--&gt; failure (because we can't move anywhere) . So when canSolve(1, 1) returns failure, we will automatically backtrack to (2, 1): . canSolve(3, 1) | +--&gt; canSolve(2, 1) | +--&gt; canSolve(1, 1) | | +--&gt; failure | +--&gt; what now? . What is the second recursive case in (2, 1)? We need to try south. But south from (2, 1) is where we arrived at (2, 1) from, so that makes no sense. Let’s try east: . canSolve(3, 1) | +--&gt; canSolve(2, 1) | +--&gt; canSolve(1, 1) | | +--&gt; return failure | +--&gt; canSolve(2, 2) . We’ve found the cup, so return success! . canSolve(3, 1) | +--&gt; canSolve(2, 1) | +--&gt; canSolve(1, 1) | | +--&gt; return failure | +--&gt; canSolve(2, 2) | +--&gt; return success (because we found the cup here) . canSolve(2, 2) returns success back to canSolve(2, 1): . canSolve(3, 1) | +--&gt; canSolve(2, 1) | +--&gt; canSolve(1, 1) | | +--&gt; return failure | +--&gt; canSolve(2, 2) | | +--&gt; return success | +--&gt; return success (because the previous recursive call was successful) . canSolve(2, 1) returns success back to canSolve(3, 1): . canSolve(3, 1) | +--&gt; canSolve(2, 1) | | +--&gt; canSolve(1, 1) | | | +--&gt; return failure | | +--&gt; canSolve(2, 2) | | | +--&gt; return success | | +--&gt; return success | +--&gt; return success (because the previous recursive call was successful) . And therefore the original recursive call to canSolve(3, 1) returns success, indicating the cup was found successfully. If this makes sense, go back to the previous page and continue. ",
    "url": "/cs142-f22/projects/proj4/rec1/",
    "relUrl": "/projects/proj4/rec1/"
  },"100": {
    "doc": "First recursive formulation",
    "title": "Second recursive formulation",
    "content": ". | Is the patronus at the same location as the cup? If so, return “C”. | Check if the patronus can move one step north. If so, recursively solve the maze from one step north. If this recursive call succeeds (the string returned is not “X”), then we return an updated string with our path. | Check if the patronus can move one step south. If so, recursively solve the maze from one step north. If this recursive call succeeds (the string returned is not “X”), then we return an updated string with our path. | Repeat for east and west. (So always north first, then south, then east, then west.) | If none of the (up to four) recursive calls succeeded, then return “X”. | . Let’s run through this idea with maze0.txt, repeated here, with labels on the rows and columns: . 0123 0#### 1# ## 2# C# 3#H## 4#### . The patronus begins at (3, 1) just like in the first formulation, so we begin by calling directionalSolve(3, 1), followed by directionalSolve(2, 1) and directionalSolve(1, 1). We again reach a dead-end at (1, 1), but instead of returning failure, we return the string “X” (indicating failure): . directionalSolve(3, 1) | +--&gt; directionalSolve(2, 1) | +--&gt; directionalSolve(1, 1) | +--&gt; return \"X\" (because we can't move anywhere) . So when directionalSolve(1, 1) returns “X”, we will automatically backtrack to (2, 1), where we try south, but we’re blocked, so we try east: . directionalSolve(3, 1) | +--&gt; directionalSolve(2, 1) | +--&gt; directionalSolve(1, 1) | | +--&gt; return \"X\" | +--&gt; directionalSolve(2, 2) . We’ve found the cup, so return “C”, indicating we found the cup. directionalSolve(3, 1) | +--&gt; directionalSolve(2, 1) | +--&gt; directionalSolve(1, 1) | | +--&gt; return \"X\" | +--&gt; directionalSolve(2, 2) | +--&gt; return \"C\" (because we found the cup here) . directionalSolve(2, 2) returns “C” back to directionalSolve(2, 1). What should we do with this “C”? It’s not “X”, so it indicates a successful search, but what should directionalSolve(2, 1) return? We can’t just return “C” again, because the cup isn’t at (2, 1). Instead, we’ll return a string indicating the direction that we walked to find the cup, which was east (so we’ll return “E”). directionalSolve(3, 1) | +--&gt; directionalSolve(2, 1) | +--&gt; directionalSolve(1, 1) | | +--&gt; return \"X\" | +--&gt; directionalSolve(2, 2) | | +--&gt; return \"C\" | +--&gt; return \"E\" (because we walked east to find the cup from here) . directionalSolve(2, 1) returns “E” back to directionalSolve(3, 1), and again, what should directionalSolve(3, 1) return? We walked north from (3, 1) to (2, 1), so let’s attach an “N” to the front of our answer: . directionalSolve(3, 1) | +--&gt; directionalSolve(2, 1) | | +--&gt; directionalSolve(1, 1) | | | +--&gt; return \"X\" | | +--&gt; directionalSolve(2, 2) | | | +--&gt; return \"C\" | | +--&gt; return \"E\" | +--&gt; return \"NE\" (because we attached an \"N\" to the previous call) . And therefore the original recursive call to solve(3, 1) returns “NE”, indicating the path to the cup from the original starting location is North, then East. If this makes sense, go back to the previous page and continue. ",
    "url": "/cs142-f22/projects/proj4/rec2/#second-recursive-formulation",
    "relUrl": "/projects/proj4/rec2/#second-recursive-formulation"
  },"101": {
    "doc": "First recursive formulation",
    "title": "First recursive formulation",
    "content": " ",
    "url": "/cs142-f22/projects/proj4/rec2/",
    "relUrl": "/projects/proj4/rec2/"
  },"102": {
    "doc": "Weekly Schedule",
    "title": "Weekly Schedule",
    "content": ". | 9:00 AM | 9:30 AM | 10:00 AM | 10:30 AM | 11:00 AM | 11:30 AM | 12:00 PM | 12:30 PM | 1:00 PM | 1:30 PM | 2:00 PM | 2:30 PM | 3:00 PM | 3:30 PM | 4:00 PM | 4:30 PM | 5:00 PM | 5:30 PM | . | ",
    "url": "/cs142-f22/schedule/",
    "relUrl": "/schedule/"
  },"103": {
    "doc": "Weekly Schedule",
    "title": "Monday",
    "content": ". | 01 Lecture 10:00 AM–10:50 AM Briggs 001 | 02 Lecture 11:00 AM–11:50 AM Briggs 001 | . | ",
    "url": "/cs142-f22/schedule/",
    "relUrl": "/schedule/"
  },"104": {
    "doc": "Weekly Schedule",
    "title": "Tuesday",
    "content": "| ",
    "url": "/cs142-f22/schedule/",
    "relUrl": "/schedule/"
  },"105": {
    "doc": "Weekly Schedule",
    "title": "Wednesday",
    "content": ". | 01 Lab 9:00 AM–10:50 AM Briggs 001 | 02 Lab 11:00 AM–12:50 PM Briggs 001 | . | ",
    "url": "/cs142-f22/schedule/",
    "relUrl": "/schedule/"
  },"106": {
    "doc": "Weekly Schedule",
    "title": "Thursday",
    "content": "| ",
    "url": "/cs142-f22/schedule/",
    "relUrl": "/schedule/"
  },"107": {
    "doc": "Weekly Schedule",
    "title": "Friday",
    "content": ". | 01 Lecture 10:00 AM–10:50 AM Briggs 001 | 02 Lecture 11:00 AM–11:50AM Briggs 001 | . | . ",
    "url": "/cs142-f22/schedule/",
    "relUrl": "/schedule/"
  }
}
